// automatically generated by the FlatBuffers compiler, do not modify

import * as flatbuffers from 'flatbuffers'

import { Array, ArrayT } from './array'
import { Bool, BoolT } from './bool'
import { Double, DoubleT } from './double'
import { Float, FloatT } from './float'
import { Int, IntT } from './int'
import { Object_, ObjectT } from './object'
import { String, StringT } from './string'
import { Type, unionToType, unionListToType } from './type'
import { UInt, UIntT } from './uint'

export class TypeWrapper {
  bb: flatbuffers.ByteBuffer | null = null
  bb_pos = 0
  __init(i: number, bb: flatbuffers.ByteBuffer): TypeWrapper {
    this.bb_pos = i
    this.bb = bb
    return this
  }

  static getRootAsTypeWrapper(
    bb: flatbuffers.ByteBuffer,
    obj?: TypeWrapper
  ): TypeWrapper {
    return (obj || new TypeWrapper()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    )
  }

  static getSizePrefixedRootAsTypeWrapper(
    bb: flatbuffers.ByteBuffer,
    obj?: TypeWrapper
  ): TypeWrapper {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH)
    return (obj || new TypeWrapper()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    )
  }

  valueType(): Type {
    const offset = this.bb!.__offset(this.bb_pos, 4)
    return offset ? this.bb!.readUint8(this.bb_pos + offset) : Type.NONE
  }

  value<T extends flatbuffers.Table>(obj: any): any | null {
    const offset = this.bb!.__offset(this.bb_pos, 6)
    return offset ? this.bb!.__union(obj, this.bb_pos + offset) : null
  }

  static startTypeWrapper(builder: flatbuffers.Builder) {
    builder.startObject(2)
  }

  static addValueType(builder: flatbuffers.Builder, valueType: Type) {
    builder.addFieldInt8(0, valueType, Type.NONE)
  }

  static addValue(
    builder: flatbuffers.Builder,
    valueOffset: flatbuffers.Offset
  ) {
    builder.addFieldOffset(1, valueOffset, 0)
  }

  static endTypeWrapper(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject()
    return offset
  }

  static createTypeWrapper(
    builder: flatbuffers.Builder,
    valueType: Type,
    valueOffset: flatbuffers.Offset
  ): flatbuffers.Offset {
    TypeWrapper.startTypeWrapper(builder)
    TypeWrapper.addValueType(builder, valueType)
    TypeWrapper.addValue(builder, valueOffset)
    return TypeWrapper.endTypeWrapper(builder)
  }

  unpack(): TypeWrapperT {
    return new TypeWrapperT(
      this.valueType(),
      (() => {
        let temp = unionToType(this.valueType(), this.value.bind(this))
        if (temp === null) {
          return null
        }
        return temp.unpack()
      })()
    )
  }

  unpackTo(_o: TypeWrapperT): void {
    _o.valueType = this.valueType()
    _o.value = (() => {
      let temp = unionToType(this.valueType(), this.value.bind(this))
      if (temp === null) {
        return null
      }
      return temp.unpack()
    })()
  }
}

export class TypeWrapperT {
  constructor(
    public valueType: Type = Type.NONE,
    public value:
      | ArrayT
      | BoolT
      | DoubleT
      | FloatT
      | IntT
      | ObjectT
      | StringT
      | UIntT
      | null = null
  ) {}

  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    const value = builder.createObjectOffset(this.value)

    return TypeWrapper.createTypeWrapper(builder, this.valueType, value)
  }
}
