# automatically generated by the FlatBuffers compiler, do not modify


import flatbuffers
from flatbuffers.compat import import_numpy

np = import_numpy()


class Type(object):
    NONE = 0
    Bool = 1
    Int = 2
    UInt = 3
    Float = 4
    Double = 5
    String = 6
    Object = 7
    Array = 8
    Blob = 9


def TypeCreator(unionType, table):
    from flatbuffers.table import Table

    if not isinstance(table, Table):
        return None
    if unionType == Type().Bool:
        return BoolT.InitFromBuf(table.Bytes, table.Pos)
    if unionType == Type().Int:
        return IntT.InitFromBuf(table.Bytes, table.Pos)
    if unionType == Type().UInt:
        return UIntT.InitFromBuf(table.Bytes, table.Pos)
    if unionType == Type().Float:
        return FloatT.InitFromBuf(table.Bytes, table.Pos)
    if unionType == Type().Double:
        return DoubleT.InitFromBuf(table.Bytes, table.Pos)
    if unionType == Type().String:
        return StringT.InitFromBuf(table.Bytes, table.Pos)
    if unionType == Type().Object:
        return ObjectT.InitFromBuf(table.Bytes, table.Pos)
    if unionType == Type().Array:
        return ArrayT.InitFromBuf(table.Bytes, table.Pos)
    if unionType == Type().Blob:
        return BlobT.InitFromBuf(table.Bytes, table.Pos)
    return None


class ComparisonRuleMode(object):
    Absolute = 0
    Relative = 1


class ResultType(object):
    Check = 1
    Assert = 2


class ComparisonRuleDouble(object):
    __slots__ = ["_tab"]

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = ComparisonRuleDouble()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsComparisonRuleDouble(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)

    # ComparisonRuleDouble
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # ComparisonRuleDouble
    def Mode(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint8Flags, o + self._tab.Pos)
        return 0

    # ComparisonRuleDouble
    def Max(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.Get(
                flatbuffers.number_types.Float64Flags, o + self._tab.Pos
            )
        return None

    # ComparisonRuleDouble
    def Min(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.Get(
                flatbuffers.number_types.Float64Flags, o + self._tab.Pos
            )
        return None

    # ComparisonRuleDouble
    def Percent(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return bool(
                self._tab.Get(flatbuffers.number_types.BoolFlags, o + self._tab.Pos)
            )
        return None


def ComparisonRuleDoubleStart(builder):
    builder.StartObject(4)


def ComparisonRuleDoubleAddMode(builder, mode):
    builder.PrependUint8Slot(0, mode, 0)


def ComparisonRuleDoubleAddMax(builder, max):
    builder.PrependFloat64Slot(1, max, None)


def ComparisonRuleDoubleAddMin(builder, min):
    builder.PrependFloat64Slot(2, min, None)


def ComparisonRuleDoubleAddPercent(builder, percent):
    builder.PrependBoolSlot(3, percent, None)


def ComparisonRuleDoubleEnd(builder):
    return builder.EndObject()


class ComparisonRuleDoubleT(object):
    # ComparisonRuleDoubleT
    def __init__(self):
        self.mode = 0  # type: int
        self.max = None  # type: Optional[float]
        self.min = None  # type: Optional[float]
        self.percent = None  # type: Optional[bool]

    @classmethod
    def InitFromBuf(cls, buf, pos):
        comparisonRuleDouble = ComparisonRuleDouble()
        comparisonRuleDouble.Init(buf, pos)
        return cls.InitFromObj(comparisonRuleDouble)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos + n)

    @classmethod
    def InitFromObj(cls, comparisonRuleDouble):
        x = ComparisonRuleDoubleT()
        x._UnPack(comparisonRuleDouble)
        return x

    # ComparisonRuleDoubleT
    def _UnPack(self, comparisonRuleDouble):
        if comparisonRuleDouble is None:
            return
        self.mode = comparisonRuleDouble.Mode()
        self.max = comparisonRuleDouble.Max()
        self.min = comparisonRuleDouble.Min()
        self.percent = comparisonRuleDouble.Percent()

    # ComparisonRuleDoubleT
    def Pack(self, builder):
        ComparisonRuleDoubleStart(builder)
        ComparisonRuleDoubleAddMode(builder, self.mode)
        ComparisonRuleDoubleAddMax(builder, self.max)
        ComparisonRuleDoubleAddMin(builder, self.min)
        ComparisonRuleDoubleAddPercent(builder, self.percent)
        comparisonRuleDouble = ComparisonRuleDoubleEnd(builder)
        return comparisonRuleDouble


class TypeWrapper(object):
    __slots__ = ["_tab"]

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = TypeWrapper()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsTypeWrapper(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)

    # TypeWrapper
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # TypeWrapper
    def ValueType(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint8Flags, o + self._tab.Pos)
        return 0

    # TypeWrapper
    def Value(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            from flatbuffers.table import Table

            obj = Table(bytearray(), 0)
            self._tab.Union(obj, o)
            return obj
        return None


def TypeWrapperStart(builder):
    builder.StartObject(2)


def TypeWrapperAddValueType(builder, valueType):
    builder.PrependUint8Slot(0, valueType, 0)


def TypeWrapperAddValue(builder, value):
    builder.PrependUOffsetTRelativeSlot(
        1, flatbuffers.number_types.UOffsetTFlags.py_type(value), 0
    )


def TypeWrapperEnd(builder):
    return builder.EndObject()


try:
    from typing import Union
except:
    pass


class TypeWrapperT(object):
    # TypeWrapperT
    def __init__(self):
        self.valueType = 0  # type: int
        self.value = (
            None
        )  # type: Union[None, BoolT, IntT, UIntT, FloatT, DoubleT, StringT, ObjectT, ArrayT, BlobT]

    @classmethod
    def InitFromBuf(cls, buf, pos):
        typeWrapper = TypeWrapper()
        typeWrapper.Init(buf, pos)
        return cls.InitFromObj(typeWrapper)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos + n)

    @classmethod
    def InitFromObj(cls, typeWrapper):
        x = TypeWrapperT()
        x._UnPack(typeWrapper)
        return x

    # TypeWrapperT
    def _UnPack(self, typeWrapper):
        if typeWrapper is None:
            return
        self.valueType = typeWrapper.ValueType()
        self.value = TypeCreator(self.valueType, typeWrapper.Value())

    # TypeWrapperT
    def Pack(self, builder):
        if self.value is not None:
            value = self.value.Pack(builder)
        TypeWrapperStart(builder)
        TypeWrapperAddValueType(builder, self.valueType)
        if self.value is not None:
            TypeWrapperAddValue(builder, value)
        typeWrapper = TypeWrapperEnd(builder)
        return typeWrapper


class Bool(object):
    __slots__ = ["_tab"]

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = Bool()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsBool(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)

    # Bool
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # Bool
    def Value(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return bool(
                self._tab.Get(flatbuffers.number_types.BoolFlags, o + self._tab.Pos)
            )
        return False


def BoolStart(builder):
    builder.StartObject(1)


def BoolAddValue(builder, value):
    builder.PrependBoolSlot(0, value, 0)


def BoolEnd(builder):
    return builder.EndObject()


class BoolT(object):
    # BoolT
    def __init__(self):
        self.value = False  # type: bool

    @classmethod
    def InitFromBuf(cls, buf, pos):
        bool = Bool()
        bool.Init(buf, pos)
        return cls.InitFromObj(bool)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos + n)

    @classmethod
    def InitFromObj(cls, bool):
        x = BoolT()
        x._UnPack(bool)
        return x

    # BoolT
    def _UnPack(self, bool):
        if bool is None:
            return
        self.value = bool.Value()

    # BoolT
    def Pack(self, builder):
        BoolStart(builder)
        BoolAddValue(builder, self.value)
        bool = BoolEnd(builder)
        return bool


class Int(object):
    __slots__ = ["_tab"]

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = Int()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsInt(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)

    # Int
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # Int
    def Value(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int64Flags, o + self._tab.Pos)
        return 0


def IntStart(builder):
    builder.StartObject(1)


def IntAddValue(builder, value):
    builder.PrependInt64Slot(0, value, 0)


def IntEnd(builder):
    return builder.EndObject()


class IntT(object):
    # IntT
    def __init__(self):
        self.value = 0  # type: int

    @classmethod
    def InitFromBuf(cls, buf, pos):
        int = Int()
        int.Init(buf, pos)
        return cls.InitFromObj(int)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos + n)

    @classmethod
    def InitFromObj(cls, int):
        x = IntT()
        x._UnPack(int)
        return x

    # IntT
    def _UnPack(self, int):
        if int is None:
            return
        self.value = int.Value()

    # IntT
    def Pack(self, builder):
        IntStart(builder)
        IntAddValue(builder, self.value)
        int = IntEnd(builder)
        return int


class UInt(object):
    __slots__ = ["_tab"]

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = UInt()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsUInt(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)

    # UInt
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # UInt
    def Value(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(
                flatbuffers.number_types.Uint64Flags, o + self._tab.Pos
            )
        return 0


def UIntStart(builder):
    builder.StartObject(1)


def UIntAddValue(builder, value):
    builder.PrependUint64Slot(0, value, 0)


def UIntEnd(builder):
    return builder.EndObject()


class UIntT(object):
    # UIntT
    def __init__(self):
        self.value = 0  # type: int

    @classmethod
    def InitFromBuf(cls, buf, pos):
        uint = UInt()
        uint.Init(buf, pos)
        return cls.InitFromObj(uint)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos + n)

    @classmethod
    def InitFromObj(cls, uint):
        x = UIntT()
        x._UnPack(uint)
        return x

    # UIntT
    def _UnPack(self, uint):
        if uint is None:
            return
        self.value = uint.Value()

    # UIntT
    def Pack(self, builder):
        UIntStart(builder)
        UIntAddValue(builder, self.value)
        uint = UIntEnd(builder)
        return uint


class Float(object):
    __slots__ = ["_tab"]

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = Float()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsFloat(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)

    # Float
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # Float
    def Value(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(
                flatbuffers.number_types.Float32Flags, o + self._tab.Pos
            )
        return 0.0


def FloatStart(builder):
    builder.StartObject(1)


def FloatAddValue(builder, value):
    builder.PrependFloat32Slot(0, value, 0.0)


def FloatEnd(builder):
    return builder.EndObject()


class FloatT(object):
    # FloatT
    def __init__(self):
        self.value = 0.0  # type: float

    @classmethod
    def InitFromBuf(cls, buf, pos):
        float = Float()
        float.Init(buf, pos)
        return cls.InitFromObj(float)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos + n)

    @classmethod
    def InitFromObj(cls, float):
        x = FloatT()
        x._UnPack(float)
        return x

    # FloatT
    def _UnPack(self, float):
        if float is None:
            return
        self.value = float.Value()

    # FloatT
    def Pack(self, builder):
        FloatStart(builder)
        FloatAddValue(builder, self.value)
        float = FloatEnd(builder)
        return float


class Double(object):
    __slots__ = ["_tab"]

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = Double()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsDouble(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)

    # Double
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # Double
    def Value(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(
                flatbuffers.number_types.Float64Flags, o + self._tab.Pos
            )
        return 0.0

    # Double
    def Rule(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            x = self._tab.Indirect(o + self._tab.Pos)
            obj = ComparisonRuleDouble()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None


def DoubleStart(builder):
    builder.StartObject(2)


def DoubleAddValue(builder, value):
    builder.PrependFloat64Slot(0, value, 0.0)


def DoubleAddRule(builder, rule):
    builder.PrependUOffsetTRelativeSlot(
        1, flatbuffers.number_types.UOffsetTFlags.py_type(rule), 0
    )


def DoubleEnd(builder):
    return builder.EndObject()


try:
    from typing import Optional
except:
    pass


class DoubleT(object):
    # DoubleT
    def __init__(self):
        self.value = 0.0  # type: float
        self.rule = None  # type: Optional[ComparisonRuleDoubleT]

    @classmethod
    def InitFromBuf(cls, buf, pos):
        double = Double()
        double.Init(buf, pos)
        return cls.InitFromObj(double)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos + n)

    @classmethod
    def InitFromObj(cls, double):
        x = DoubleT()
        x._UnPack(double)
        return x

    # DoubleT
    def _UnPack(self, double):
        if double is None:
            return
        self.value = double.Value()
        if double.Rule() is not None:
            self.rule = ComparisonRuleDoubleT.InitFromObj(double.Rule())

    # DoubleT
    def Pack(self, builder):
        if self.rule is not None:
            rule = self.rule.Pack(builder)
        DoubleStart(builder)
        DoubleAddValue(builder, self.value)
        if self.rule is not None:
            DoubleAddRule(builder, rule)
        double = DoubleEnd(builder)
        return double


class String(object):
    __slots__ = ["_tab"]

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = String()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsString(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)

    # String
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # String
    def Value(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None


def StringStart(builder):
    builder.StartObject(1)


def StringAddValue(builder, value):
    builder.PrependUOffsetTRelativeSlot(
        0, flatbuffers.number_types.UOffsetTFlags.py_type(value), 0
    )


def StringEnd(builder):
    return builder.EndObject()


class StringT(object):
    # StringT
    def __init__(self):
        self.value = None  # type: str

    @classmethod
    def InitFromBuf(cls, buf, pos):
        string = String()
        string.Init(buf, pos)
        return cls.InitFromObj(string)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos + n)

    @classmethod
    def InitFromObj(cls, string):
        x = StringT()
        x._UnPack(string)
        return x

    # StringT
    def _UnPack(self, string):
        if string is None:
            return
        self.value = string.Value()

    # StringT
    def Pack(self, builder):
        if self.value is not None:
            value = builder.CreateString(self.value)
        StringStart(builder)
        if self.value is not None:
            StringAddValue(builder, value)
        string = StringEnd(builder)
        return string


class ObjectMember(object):
    __slots__ = ["_tab"]

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = ObjectMember()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsObjectMember(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)

    # ObjectMember
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # ObjectMember
    def Name(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # ObjectMember
    def Value(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            x = self._tab.Indirect(o + self._tab.Pos)
            obj = TypeWrapper()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None


def ObjectMemberStart(builder):
    builder.StartObject(2)


def ObjectMemberAddName(builder, name):
    builder.PrependUOffsetTRelativeSlot(
        0, flatbuffers.number_types.UOffsetTFlags.py_type(name), 0
    )


def ObjectMemberAddValue(builder, value):
    builder.PrependUOffsetTRelativeSlot(
        1, flatbuffers.number_types.UOffsetTFlags.py_type(value), 0
    )


def ObjectMemberEnd(builder):
    return builder.EndObject()


try:
    from typing import Optional
except:
    pass


class ObjectMemberT(object):
    # ObjectMemberT
    def __init__(self):
        self.name = None  # type: str
        self.value = None  # type: Optional[TypeWrapperT]

    @classmethod
    def InitFromBuf(cls, buf, pos):
        objectMember = ObjectMember()
        objectMember.Init(buf, pos)
        return cls.InitFromObj(objectMember)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos + n)

    @classmethod
    def InitFromObj(cls, objectMember):
        x = ObjectMemberT()
        x._UnPack(objectMember)
        return x

    # ObjectMemberT
    def _UnPack(self, objectMember):
        if objectMember is None:
            return
        self.name = objectMember.Name()
        if objectMember.Value() is not None:
            self.value = TypeWrapperT.InitFromObj(objectMember.Value())

    # ObjectMemberT
    def Pack(self, builder):
        if self.name is not None:
            name = builder.CreateString(self.name)
        if self.value is not None:
            value = self.value.Pack(builder)
        ObjectMemberStart(builder)
        if self.name is not None:
            ObjectMemberAddName(builder, name)
        if self.value is not None:
            ObjectMemberAddValue(builder, value)
        objectMember = ObjectMemberEnd(builder)
        return objectMember


class Object(object):
    __slots__ = ["_tab"]

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = Object()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsObject(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)

    # Object
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # Object
    def Key(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Object
    def Values(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            obj = ObjectMember()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # Object
    def ValuesLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Object
    def ValuesIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        return o == 0


def ObjectStart(builder):
    builder.StartObject(2)


def ObjectAddKey(builder, key):
    builder.PrependUOffsetTRelativeSlot(
        0, flatbuffers.number_types.UOffsetTFlags.py_type(key), 0
    )


def ObjectAddValues(builder, values):
    builder.PrependUOffsetTRelativeSlot(
        1, flatbuffers.number_types.UOffsetTFlags.py_type(values), 0
    )


def ObjectStartValuesVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)


def ObjectEnd(builder):
    return builder.EndObject()


try:
    from typing import List
except:
    pass


class ObjectT(object):
    # ObjectT
    def __init__(self):
        self.key = None  # type: str
        self.values = None  # type: List[ObjectMemberT]

    @classmethod
    def InitFromBuf(cls, buf, pos):
        object = Object()
        object.Init(buf, pos)
        return cls.InitFromObj(object)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos + n)

    @classmethod
    def InitFromObj(cls, object):
        x = ObjectT()
        x._UnPack(object)
        return x

    # ObjectT
    def _UnPack(self, object):
        if object is None:
            return
        self.key = object.Key()
        if not object.ValuesIsNone():
            self.values = []
            for i in range(object.ValuesLength()):
                if object.Values(i) is None:
                    self.values.append(None)
                else:
                    objectMember_ = ObjectMemberT.InitFromObj(object.Values(i))
                    self.values.append(objectMember_)

    # ObjectT
    def Pack(self, builder):
        if self.key is not None:
            key = builder.CreateString(self.key)
        if self.values is not None:
            valueslist = []
            for i in range(len(self.values)):
                valueslist.append(self.values[i].Pack(builder))
            ObjectStartValuesVector(builder, len(self.values))
            for i in reversed(range(len(self.values))):
                builder.PrependUOffsetTRelative(valueslist[i])
            values = builder.EndVector()
        ObjectStart(builder)
        if self.key is not None:
            ObjectAddKey(builder, key)
        if self.values is not None:
            ObjectAddValues(builder, values)
        object = ObjectEnd(builder)
        return object


class Array(object):
    __slots__ = ["_tab"]

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = Array()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsArray(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)

    # Array
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # Array
    def Values(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            obj = TypeWrapper()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # Array
    def ValuesLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Array
    def ValuesIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        return o == 0


def ArrayStart(builder):
    builder.StartObject(1)


def ArrayAddValues(builder, values):
    builder.PrependUOffsetTRelativeSlot(
        0, flatbuffers.number_types.UOffsetTFlags.py_type(values), 0
    )


def ArrayStartValuesVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)


def ArrayEnd(builder):
    return builder.EndObject()


try:
    from typing import List
except:
    pass


class ArrayT(object):
    # ArrayT
    def __init__(self):
        self.values = None  # type: List[TypeWrapperT]

    @classmethod
    def InitFromBuf(cls, buf, pos):
        array = Array()
        array.Init(buf, pos)
        return cls.InitFromObj(array)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos + n)

    @classmethod
    def InitFromObj(cls, array):
        x = ArrayT()
        x._UnPack(array)
        return x

    # ArrayT
    def _UnPack(self, array):
        if array is None:
            return
        if not array.ValuesIsNone():
            self.values = []
            for i in range(array.ValuesLength()):
                if array.Values(i) is None:
                    self.values.append(None)
                else:
                    typeWrapper_ = TypeWrapperT.InitFromObj(array.Values(i))
                    self.values.append(typeWrapper_)

    # ArrayT
    def Pack(self, builder):
        if self.values is not None:
            valueslist = []
            for i in range(len(self.values)):
                valueslist.append(self.values[i].Pack(builder))
            ArrayStartValuesVector(builder, len(self.values))
            for i in reversed(range(len(self.values))):
                builder.PrependUOffsetTRelative(valueslist[i])
            values = builder.EndVector()
        ArrayStart(builder)
        if self.values is not None:
            ArrayAddValues(builder, values)
        array = ArrayEnd(builder)
        return array


class Blob(object):
    __slots__ = ["_tab"]

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = Blob()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsBlob(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)

    # Blob
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # Blob
    def Digest(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Blob
    def Mimetype(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Blob
    def Reference(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None


def BlobStart(builder):
    builder.StartObject(3)


def BlobAddDigest(builder, digest):
    builder.PrependUOffsetTRelativeSlot(
        0, flatbuffers.number_types.UOffsetTFlags.py_type(digest), 0
    )


def BlobAddMimetype(builder, mimetype):
    builder.PrependUOffsetTRelativeSlot(
        1, flatbuffers.number_types.UOffsetTFlags.py_type(mimetype), 0
    )


def BlobAddReference(builder, reference):
    builder.PrependUOffsetTRelativeSlot(
        2, flatbuffers.number_types.UOffsetTFlags.py_type(reference), 0
    )


def BlobEnd(builder):
    return builder.EndObject()


class BlobT(object):
    # BlobT
    def __init__(self):
        self.digest = None  # type: str
        self.mimetype = None  # type: str
        self.reference = None  # type: str

    @classmethod
    def InitFromBuf(cls, buf, pos):
        blob = Blob()
        blob.Init(buf, pos)
        return cls.InitFromObj(blob)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos + n)

    @classmethod
    def InitFromObj(cls, blob):
        x = BlobT()
        x._UnPack(blob)
        return x

    # BlobT
    def _UnPack(self, blob):
        if blob is None:
            return
        self.digest = blob.Digest()
        self.mimetype = blob.Mimetype()
        self.reference = blob.Reference()

    # BlobT
    def Pack(self, builder):
        if self.digest is not None:
            digest = builder.CreateString(self.digest)
        if self.mimetype is not None:
            mimetype = builder.CreateString(self.mimetype)
        if self.reference is not None:
            reference = builder.CreateString(self.reference)
        BlobStart(builder)
        if self.digest is not None:
            BlobAddDigest(builder, digest)
        if self.mimetype is not None:
            BlobAddMimetype(builder, mimetype)
        if self.reference is not None:
            BlobAddReference(builder, reference)
        blob = BlobEnd(builder)
        return blob


class Result(object):
    __slots__ = ["_tab"]

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = Result()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsResult(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)

    # Result
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # Result
    def Key(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Result
    def Value(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            x = self._tab.Indirect(o + self._tab.Pos)
            obj = TypeWrapper()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # Result
    def Typ(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint8Flags, o + self._tab.Pos)
        return 1


def ResultStart(builder):
    builder.StartObject(3)


def ResultAddKey(builder, key):
    builder.PrependUOffsetTRelativeSlot(
        0, flatbuffers.number_types.UOffsetTFlags.py_type(key), 0
    )


def ResultAddValue(builder, value):
    builder.PrependUOffsetTRelativeSlot(
        1, flatbuffers.number_types.UOffsetTFlags.py_type(value), 0
    )


def ResultAddTyp(builder, typ):
    builder.PrependUint8Slot(2, typ, 1)


def ResultEnd(builder):
    return builder.EndObject()


try:
    from typing import Optional
except:
    pass


class ResultT(object):
    # ResultT
    def __init__(self):
        self.key = None  # type: str
        self.value = None  # type: Optional[TypeWrapperT]
        self.typ = 1  # type: int

    @classmethod
    def InitFromBuf(cls, buf, pos):
        result = Result()
        result.Init(buf, pos)
        return cls.InitFromObj(result)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos + n)

    @classmethod
    def InitFromObj(cls, result):
        x = ResultT()
        x._UnPack(result)
        return x

    # ResultT
    def _UnPack(self, result):
        if result is None:
            return
        self.key = result.Key()
        if result.Value() is not None:
            self.value = TypeWrapperT.InitFromObj(result.Value())
        self.typ = result.Typ()

    # ResultT
    def Pack(self, builder):
        if self.key is not None:
            key = builder.CreateString(self.key)
        if self.value is not None:
            value = self.value.Pack(builder)
        ResultStart(builder)
        if self.key is not None:
            ResultAddKey(builder, key)
        if self.value is not None:
            ResultAddValue(builder, value)
        ResultAddTyp(builder, self.typ)
        result = ResultEnd(builder)
        return result


class Assertion(object):
    __slots__ = ["_tab"]

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = Assertion()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsAssertion(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)

    # Assertion
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)


def AssertionStart(builder):
    builder.StartObject(2)


def AssertionEnd(builder):
    return builder.EndObject()


class AssertionT(object):
    # AssertionT
    def __init__(self):
        pass

    @classmethod
    def InitFromBuf(cls, buf, pos):
        assertion = Assertion()
        assertion.Init(buf, pos)
        return cls.InitFromObj(assertion)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos + n)

    @classmethod
    def InitFromObj(cls, assertion):
        x = AssertionT()
        x._UnPack(assertion)
        return x

    # AssertionT
    def _UnPack(self, assertion):
        if assertion is None:
            return

    # AssertionT
    def Pack(self, builder):
        AssertionStart(builder)
        assertion = AssertionEnd(builder)
        return assertion


class Metric(object):
    __slots__ = ["_tab"]

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = Metric()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsMetric(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)

    # Metric
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # Metric
    def Key(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Metric
    def Value(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            x = self._tab.Indirect(o + self._tab.Pos)
            obj = TypeWrapper()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None


def MetricStart(builder):
    builder.StartObject(2)


def MetricAddKey(builder, key):
    builder.PrependUOffsetTRelativeSlot(
        0, flatbuffers.number_types.UOffsetTFlags.py_type(key), 0
    )


def MetricAddValue(builder, value):
    builder.PrependUOffsetTRelativeSlot(
        1, flatbuffers.number_types.UOffsetTFlags.py_type(value), 0
    )


def MetricEnd(builder):
    return builder.EndObject()


try:
    from typing import Optional
except:
    pass


class MetricT(object):
    # MetricT
    def __init__(self):
        self.key = None  # type: str
        self.value = None  # type: Optional[TypeWrapperT]

    @classmethod
    def InitFromBuf(cls, buf, pos):
        metric = Metric()
        metric.Init(buf, pos)
        return cls.InitFromObj(metric)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos + n)

    @classmethod
    def InitFromObj(cls, metric):
        x = MetricT()
        x._UnPack(metric)
        return x

    # MetricT
    def _UnPack(self, metric):
        if metric is None:
            return
        self.key = metric.Key()
        if metric.Value() is not None:
            self.value = TypeWrapperT.InitFromObj(metric.Value())

    # MetricT
    def Pack(self, builder):
        if self.key is not None:
            key = builder.CreateString(self.key)
        if self.value is not None:
            value = self.value.Pack(builder)
        MetricStart(builder)
        if self.key is not None:
            MetricAddKey(builder, key)
        if self.value is not None:
            MetricAddValue(builder, value)
        metric = MetricEnd(builder)
        return metric


class Results(object):
    __slots__ = ["_tab"]

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = Results()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsResults(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)

    # Results
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # Results
    def Entries(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            obj = Result()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # Results
    def EntriesLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Results
    def EntriesIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        return o == 0


def ResultsStart(builder):
    builder.StartObject(1)


def ResultsAddEntries(builder, entries):
    builder.PrependUOffsetTRelativeSlot(
        0, flatbuffers.number_types.UOffsetTFlags.py_type(entries), 0
    )


def ResultsStartEntriesVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)


def ResultsEnd(builder):
    return builder.EndObject()


try:
    from typing import List
except:
    pass


class ResultsT(object):
    # ResultsT
    def __init__(self):
        self.entries = None  # type: List[ResultT]

    @classmethod
    def InitFromBuf(cls, buf, pos):
        results = Results()
        results.Init(buf, pos)
        return cls.InitFromObj(results)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos + n)

    @classmethod
    def InitFromObj(cls, results):
        x = ResultsT()
        x._UnPack(results)
        return x

    # ResultsT
    def _UnPack(self, results):
        if results is None:
            return
        if not results.EntriesIsNone():
            self.entries = []
            for i in range(results.EntriesLength()):
                if results.Entries(i) is None:
                    self.entries.append(None)
                else:
                    result_ = ResultT.InitFromObj(results.Entries(i))
                    self.entries.append(result_)

    # ResultsT
    def Pack(self, builder):
        if self.entries is not None:
            entrieslist = []
            for i in range(len(self.entries)):
                entrieslist.append(self.entries[i].Pack(builder))
            ResultsStartEntriesVector(builder, len(self.entries))
            for i in reversed(range(len(self.entries))):
                builder.PrependUOffsetTRelative(entrieslist[i])
            entries = builder.EndVector()
        ResultsStart(builder)
        if self.entries is not None:
            ResultsAddEntries(builder, entries)
        results = ResultsEnd(builder)
        return results


class Assertions(object):
    __slots__ = ["_tab"]

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = Assertions()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsAssertions(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)

    # Assertions
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)


def AssertionsStart(builder):
    builder.StartObject(1)


def AssertionsEnd(builder):
    return builder.EndObject()


class AssertionsT(object):
    # AssertionsT
    def __init__(self):
        pass

    @classmethod
    def InitFromBuf(cls, buf, pos):
        assertions = Assertions()
        assertions.Init(buf, pos)
        return cls.InitFromObj(assertions)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos + n)

    @classmethod
    def InitFromObj(cls, assertions):
        x = AssertionsT()
        x._UnPack(assertions)
        return x

    # AssertionsT
    def _UnPack(self, assertions):
        if assertions is None:
            return

    # AssertionsT
    def Pack(self, builder):
        AssertionsStart(builder)
        assertions = AssertionsEnd(builder)
        return assertions


class Metrics(object):
    __slots__ = ["_tab"]

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = Metrics()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsMetrics(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)

    # Metrics
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # Metrics
    def Entries(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            obj = Metric()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # Metrics
    def EntriesLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Metrics
    def EntriesIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        return o == 0


def MetricsStart(builder):
    builder.StartObject(1)


def MetricsAddEntries(builder, entries):
    builder.PrependUOffsetTRelativeSlot(
        0, flatbuffers.number_types.UOffsetTFlags.py_type(entries), 0
    )


def MetricsStartEntriesVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)


def MetricsEnd(builder):
    return builder.EndObject()


try:
    from typing import List
except:
    pass


class MetricsT(object):
    # MetricsT
    def __init__(self):
        self.entries = None  # type: List[MetricT]

    @classmethod
    def InitFromBuf(cls, buf, pos):
        metrics = Metrics()
        metrics.Init(buf, pos)
        return cls.InitFromObj(metrics)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos + n)

    @classmethod
    def InitFromObj(cls, metrics):
        x = MetricsT()
        x._UnPack(metrics)
        return x

    # MetricsT
    def _UnPack(self, metrics):
        if metrics is None:
            return
        if not metrics.EntriesIsNone():
            self.entries = []
            for i in range(metrics.EntriesLength()):
                if metrics.Entries(i) is None:
                    self.entries.append(None)
                else:
                    metric_ = MetricT.InitFromObj(metrics.Entries(i))
                    self.entries.append(metric_)

    # MetricsT
    def Pack(self, builder):
        if self.entries is not None:
            entrieslist = []
            for i in range(len(self.entries)):
                entrieslist.append(self.entries[i].Pack(builder))
            MetricsStartEntriesVector(builder, len(self.entries))
            for i in reversed(range(len(self.entries))):
                builder.PrependUOffsetTRelative(entrieslist[i])
            entries = builder.EndVector()
        MetricsStart(builder)
        if self.entries is not None:
            MetricsAddEntries(builder, entries)
        metrics = MetricsEnd(builder)
        return metrics


class Metadata(object):
    __slots__ = ["_tab"]

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = Metadata()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsMetadata(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)

    # Metadata
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # Metadata
    def Testsuite(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Metadata
    def Version(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Metadata
    def Testcase(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Metadata
    def BuiltAt(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Metadata
    def Teamslug(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None


def MetadataStart(builder):
    builder.StartObject(6)


def MetadataAddTestsuite(builder, testsuite):
    builder.PrependUOffsetTRelativeSlot(
        0, flatbuffers.number_types.UOffsetTFlags.py_type(testsuite), 0
    )


def MetadataAddVersion(builder, version):
    builder.PrependUOffsetTRelativeSlot(
        1, flatbuffers.number_types.UOffsetTFlags.py_type(version), 0
    )


def MetadataAddTestcase(builder, testcase):
    builder.PrependUOffsetTRelativeSlot(
        3, flatbuffers.number_types.UOffsetTFlags.py_type(testcase), 0
    )


def MetadataAddBuiltAt(builder, builtAt):
    builder.PrependUOffsetTRelativeSlot(
        4, flatbuffers.number_types.UOffsetTFlags.py_type(builtAt), 0
    )


def MetadataAddTeamslug(builder, teamslug):
    builder.PrependUOffsetTRelativeSlot(
        5, flatbuffers.number_types.UOffsetTFlags.py_type(teamslug), 0
    )


def MetadataEnd(builder):
    return builder.EndObject()


class MetadataT(object):
    # MetadataT
    def __init__(self):
        self.testsuite = None  # type: str
        self.version = None  # type: str
        self.testcase = None  # type: str
        self.builtAt = None  # type: str
        self.teamslug = None  # type: str

    @classmethod
    def InitFromBuf(cls, buf, pos):
        metadata = Metadata()
        metadata.Init(buf, pos)
        return cls.InitFromObj(metadata)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos + n)

    @classmethod
    def InitFromObj(cls, metadata):
        x = MetadataT()
        x._UnPack(metadata)
        return x

    # MetadataT
    def _UnPack(self, metadata):
        if metadata is None:
            return
        self.testsuite = metadata.Testsuite()
        self.version = metadata.Version()
        self.testcase = metadata.Testcase()
        self.builtAt = metadata.BuiltAt()
        self.teamslug = metadata.Teamslug()

    # MetadataT
    def Pack(self, builder):
        if self.testsuite is not None:
            testsuite = builder.CreateString(self.testsuite)
        if self.version is not None:
            version = builder.CreateString(self.version)
        if self.testcase is not None:
            testcase = builder.CreateString(self.testcase)
        if self.builtAt is not None:
            builtAt = builder.CreateString(self.builtAt)
        if self.teamslug is not None:
            teamslug = builder.CreateString(self.teamslug)
        MetadataStart(builder)
        if self.testsuite is not None:
            MetadataAddTestsuite(builder, testsuite)
        if self.version is not None:
            MetadataAddVersion(builder, version)
        if self.testcase is not None:
            MetadataAddTestcase(builder, testcase)
        if self.builtAt is not None:
            MetadataAddBuiltAt(builder, builtAt)
        if self.teamslug is not None:
            MetadataAddTeamslug(builder, teamslug)
        metadata = MetadataEnd(builder)
        return metadata


class Message(object):
    __slots__ = ["_tab"]

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = Message()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsMessage(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)

    # Message
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # Message
    def Metadata(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            x = self._tab.Indirect(o + self._tab.Pos)
            obj = Metadata()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # Message
    def Results(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            x = self._tab.Indirect(o + self._tab.Pos)
            obj = Results()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # Message
    def Metrics(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            x = self._tab.Indirect(o + self._tab.Pos)
            obj = Metrics()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None


def MessageStart(builder):
    builder.StartObject(4)


def MessageAddMetadata(builder, metadata):
    builder.PrependUOffsetTRelativeSlot(
        0, flatbuffers.number_types.UOffsetTFlags.py_type(metadata), 0
    )


def MessageAddResults(builder, results):
    builder.PrependUOffsetTRelativeSlot(
        1, flatbuffers.number_types.UOffsetTFlags.py_type(results), 0
    )


def MessageAddMetrics(builder, metrics):
    builder.PrependUOffsetTRelativeSlot(
        3, flatbuffers.number_types.UOffsetTFlags.py_type(metrics), 0
    )


def MessageEnd(builder):
    return builder.EndObject()


try:
    from typing import Optional
except:
    pass


class MessageT(object):
    # MessageT
    def __init__(self):
        self.metadata = None  # type: Optional[MetadataT]
        self.results = None  # type: Optional[ResultsT]
        self.metrics = None  # type: Optional[MetricsT]

    @classmethod
    def InitFromBuf(cls, buf, pos):
        message = Message()
        message.Init(buf, pos)
        return cls.InitFromObj(message)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos + n)

    @classmethod
    def InitFromObj(cls, message):
        x = MessageT()
        x._UnPack(message)
        return x

    # MessageT
    def _UnPack(self, message):
        if message is None:
            return
        if message.Metadata() is not None:
            self.metadata = MetadataT.InitFromObj(message.Metadata())
        if message.Results() is not None:
            self.results = ResultsT.InitFromObj(message.Results())
        if message.Metrics() is not None:
            self.metrics = MetricsT.InitFromObj(message.Metrics())

    # MessageT
    def Pack(self, builder):
        if self.metadata is not None:
            metadata = self.metadata.Pack(builder)
        if self.results is not None:
            results = self.results.Pack(builder)
        if self.metrics is not None:
            metrics = self.metrics.Pack(builder)
        MessageStart(builder)
        if self.metadata is not None:
            MessageAddMetadata(builder, metadata)
        if self.results is not None:
            MessageAddResults(builder, results)
        if self.metrics is not None:
            MessageAddMetrics(builder, metrics)
        message = MessageEnd(builder)
        return message


class MessageBuffer(object):
    __slots__ = ["_tab"]

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = MessageBuffer()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsMessageBuffer(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)

    # MessageBuffer
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # MessageBuffer
    def Buf(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(
                flatbuffers.number_types.Uint8Flags,
                a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 1),
            )
        return 0

    # MessageBuffer
    def BufAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Uint8Flags, o)
        return 0

    # MessageBuffer
    def BufNestedRoot(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return Message.GetRootAsMessage(self._tab.Bytes, self._tab.Vector(o))
        return 0

    # MessageBuffer
    def BufLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # MessageBuffer
    def BufIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        return o == 0


def MessageBufferStart(builder):
    builder.StartObject(1)


def MessageBufferAddBuf(builder, buf):
    builder.PrependUOffsetTRelativeSlot(
        0, flatbuffers.number_types.UOffsetTFlags.py_type(buf), 0
    )


def MessageBufferStartBufVector(builder, numElems):
    return builder.StartVector(1, numElems, 1)


def MessageBufferMakeBufVectorFromBytes(builder, bytes):
    builder.StartVector(1, len(bytes), 1)
    builder.head = builder.head - len(bytes)
    builder.Bytes[builder.head : builder.head + len(bytes)] = bytes
    return builder.EndVector()


def MessageBufferEnd(builder):
    return builder.EndObject()


try:
    from typing import List
except:
    pass


class MessageBufferT(object):
    # MessageBufferT
    def __init__(self):
        self.buf = None  # type: List[int]

    @classmethod
    def InitFromBuf(cls, buf, pos):
        messageBuffer = MessageBuffer()
        messageBuffer.Init(buf, pos)
        return cls.InitFromObj(messageBuffer)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos + n)

    @classmethod
    def InitFromObj(cls, messageBuffer):
        x = MessageBufferT()
        x._UnPack(messageBuffer)
        return x

    # MessageBufferT
    def _UnPack(self, messageBuffer):
        if messageBuffer is None:
            return
        if not messageBuffer.BufIsNone():
            if np is None:
                self.buf = []
                for i in range(messageBuffer.BufLength()):
                    self.buf.append(messageBuffer.Buf(i))
            else:
                self.buf = messageBuffer.BufAsNumpy()

    # MessageBufferT
    def Pack(self, builder):
        if self.buf is not None:
            if np is not None and type(self.buf) is np.ndarray:
                buf = builder.CreateNumpyVector(self.buf)
            else:
                MessageBufferStartBufVector(builder, len(self.buf))
                for i in reversed(range(len(self.buf))):
                    builder.PrependUint8(self.buf[i])
                buf = builder.EndVector()
        MessageBufferStart(builder)
        if self.buf is not None:
            MessageBufferAddBuf(builder, buf)
        messageBuffer = MessageBufferEnd(builder)
        return messageBuffer


class Messages(object):
    __slots__ = ["_tab"]

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = Messages()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsMessages(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)

    # Messages
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # Messages
    def Messages(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            obj = MessageBuffer()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # Messages
    def MessagesLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Messages
    def MessagesIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        return o == 0


def MessagesStart(builder):
    builder.StartObject(1)


def MessagesAddMessages(builder, messages):
    builder.PrependUOffsetTRelativeSlot(
        0, flatbuffers.number_types.UOffsetTFlags.py_type(messages), 0
    )


def MessagesStartMessagesVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)


def MessagesEnd(builder):
    return builder.EndObject()


try:
    from typing import List
except:
    pass


class MessagesT(object):
    # MessagesT
    def __init__(self):
        self.messages = None  # type: List[MessageBufferT]

    @classmethod
    def InitFromBuf(cls, buf, pos):
        messages = Messages()
        messages.Init(buf, pos)
        return cls.InitFromObj(messages)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos + n)

    @classmethod
    def InitFromObj(cls, messages):
        x = MessagesT()
        x._UnPack(messages)
        return x

    # MessagesT
    def _UnPack(self, messages):
        if messages is None:
            return
        if not messages.MessagesIsNone():
            self.messages = []
            for i in range(messages.MessagesLength()):
                if messages.Messages(i) is None:
                    self.messages.append(None)
                else:
                    messageBuffer_ = MessageBufferT.InitFromObj(messages.Messages(i))
                    self.messages.append(messageBuffer_)

    # MessagesT
    def Pack(self, builder):
        if self.messages is not None:
            messageslist = []
            for i in range(len(self.messages)):
                messageslist.append(self.messages[i].Pack(builder))
            MessagesStartMessagesVector(builder, len(self.messages))
            for i in reversed(range(len(self.messages))):
                builder.PrependUOffsetTRelative(messageslist[i])
            messages = builder.EndVector()
        MessagesStart(builder)
        if self.messages is not None:
            MessagesAddMessages(builder, messages)
        messages = MessagesEnd(builder)
        return messages
