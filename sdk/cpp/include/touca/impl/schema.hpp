// automatically generated by the FlatBuffers compiler, do not modify

#pragma once

#include "flatbuffers/flatbuffers.h"

namespace touca {
namespace fbs {

struct ComparisonRuleDouble;
struct ComparisonRuleDoubleBuilder;

struct TypeWrapper;
struct TypeWrapperBuilder;

struct Bool;
struct BoolBuilder;

struct Int;
struct IntBuilder;

struct UInt;
struct UIntBuilder;

struct Float;
struct FloatBuilder;

struct Double;
struct DoubleBuilder;

struct String;
struct StringBuilder;

struct ObjectMember;
struct ObjectMemberBuilder;

struct Object;
struct ObjectBuilder;

struct Array;
struct ArrayBuilder;

struct Blob;
struct BlobBuilder;

struct Result;
struct ResultBuilder;

struct Assertion;
struct AssertionBuilder;

struct Metric;
struct MetricBuilder;

struct Results;
struct ResultsBuilder;

struct Assertions;
struct AssertionsBuilder;

struct Metrics;
struct MetricsBuilder;

struct Metadata;
struct MetadataBuilder;

struct Message;
struct MessageBuilder;

struct MessageBuffer;
struct MessageBufferBuilder;

struct Messages;
struct MessagesBuilder;

enum class Type : uint8_t {
  NONE = 0,
  Bool = 1,
  Int = 2,
  UInt = 3,
  Float = 4,
  Double = 5,
  String = 6,
  Object = 7,
  Array = 8,
  Blob = 9,
  MIN = NONE,
  MAX = Blob
};

bool VerifyType(flatbuffers::Verifier& verifier, const void* obj, Type type);
bool VerifyTypeVector(
    flatbuffers::Verifier& verifier,
    const flatbuffers::Vector<flatbuffers::Offset<void>>* values,
    const flatbuffers::Vector<Type>* types);

enum class ComparisonRuleMode : uint8_t {
  Absolute = 0,
  Relative = 1,
  MIN = Absolute,
  MAX = Relative
};

enum class ResultType : uint8_t {
  Check = 1,
  Assert = 2,
  MIN = Check,
  MAX = Assert
};

struct ComparisonRuleDouble FLATBUFFERS_FINAL_CLASS
    : private flatbuffers::Table {
  typedef ComparisonRuleDoubleBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MODE = 4,
    VT_MAX = 6,
    VT_MIN = 8,
    VT_PERCENT = 10
  };
  touca::fbs::ComparisonRuleMode mode() const {
    return static_cast<touca::fbs::ComparisonRuleMode>(
        GetField<uint8_t>(VT_MODE, 0));
  }
  flatbuffers::Optional<double> max() const {
    return GetOptional<double, double>(VT_MAX);
  }
  flatbuffers::Optional<double> min() const {
    return GetOptional<double, double>(VT_MIN);
  }
  flatbuffers::Optional<bool> percent() const {
    return GetOptional<uint8_t, bool>(VT_PERCENT);
  }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_MODE) &&
           VerifyField<double>(verifier, VT_MAX) &&
           VerifyField<double>(verifier, VT_MIN) &&
           VerifyField<uint8_t>(verifier, VT_PERCENT) && verifier.EndTable();
  }
};

struct ComparisonRuleDoubleBuilder {
  typedef ComparisonRuleDouble Table;
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  void add_mode(touca::fbs::ComparisonRuleMode mode) {
    fbb_.AddElement<uint8_t>(ComparisonRuleDouble::VT_MODE,
                             static_cast<uint8_t>(mode), 0);
  }
  void add_max(double max) {
    fbb_.AddElement<double>(ComparisonRuleDouble::VT_MAX, max);
  }
  void add_min(double min) {
    fbb_.AddElement<double>(ComparisonRuleDouble::VT_MIN, min);
  }
  void add_percent(bool percent) {
    fbb_.AddElement<uint8_t>(ComparisonRuleDouble::VT_PERCENT,
                             static_cast<uint8_t>(percent));
  }
  explicit ComparisonRuleDoubleBuilder(flatbuffers::FlatBufferBuilder& _fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ComparisonRuleDouble> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ComparisonRuleDouble>(end);
    return o;
  }
};

inline flatbuffers::Offset<ComparisonRuleDouble> CreateComparisonRuleDouble(
    flatbuffers::FlatBufferBuilder& _fbb,
    touca::fbs::ComparisonRuleMode mode =
        touca::fbs::ComparisonRuleMode::Absolute,
    flatbuffers::Optional<double> max = flatbuffers::nullopt,
    flatbuffers::Optional<double> min = flatbuffers::nullopt,
    flatbuffers::Optional<bool> percent = flatbuffers::nullopt) {
  ComparisonRuleDoubleBuilder builder_(_fbb);
  if (min) {
    builder_.add_min(*min);
  }
  if (max) {
    builder_.add_max(*max);
  }
  if (percent) {
    builder_.add_percent(*percent);
  }
  builder_.add_mode(mode);
  return builder_.Finish();
}

struct TypeWrapper FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TypeWrapperBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE_TYPE = 4,
    VT_VALUE = 6
  };
  touca::fbs::Type value_type() const {
    return static_cast<touca::fbs::Type>(GetField<uint8_t>(VT_VALUE_TYPE, 0));
  }
  const void* value() const { return GetPointer<const void*>(VT_VALUE); }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_VALUE_TYPE) &&
           VerifyOffset(verifier, VT_VALUE) &&
           VerifyType(verifier, value(), value_type()) && verifier.EndTable();
  }
};

struct TypeWrapperBuilder {
  typedef TypeWrapper Table;
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  void add_value_type(touca::fbs::Type value_type) {
    fbb_.AddElement<uint8_t>(TypeWrapper::VT_VALUE_TYPE,
                             static_cast<uint8_t>(value_type), 0);
  }
  void add_value(flatbuffers::Offset<void> value) {
    fbb_.AddOffset(TypeWrapper::VT_VALUE, value);
  }
  explicit TypeWrapperBuilder(flatbuffers::FlatBufferBuilder& _fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TypeWrapper> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TypeWrapper>(end);
    return o;
  }
};

inline flatbuffers::Offset<TypeWrapper> CreateTypeWrapper(
    flatbuffers::FlatBufferBuilder& _fbb,
    touca::fbs::Type value_type = touca::fbs::Type::NONE,
    flatbuffers::Offset<void> value = 0) {
  TypeWrapperBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_value_type(value_type);
  return builder_.Finish();
}

struct Bool FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BoolBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  bool value() const { return GetField<uint8_t>(VT_VALUE, 0) != 0; }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_VALUE) && verifier.EndTable();
  }
};

struct BoolBuilder {
  typedef Bool Table;
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(bool value) {
    fbb_.AddElement<uint8_t>(Bool::VT_VALUE, static_cast<uint8_t>(value), 0);
  }
  explicit BoolBuilder(flatbuffers::FlatBufferBuilder& _fbb) : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Bool> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Bool>(end);
    return o;
  }
};

inline flatbuffers::Offset<Bool> CreateBool(
    flatbuffers::FlatBufferBuilder& _fbb, bool value = false) {
  BoolBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct Int FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef IntBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  int64_t value() const { return GetField<int64_t>(VT_VALUE, 0); }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_VALUE) && verifier.EndTable();
  }
};

struct IntBuilder {
  typedef Int Table;
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(int64_t value) {
    fbb_.AddElement<int64_t>(Int::VT_VALUE, value, 0);
  }
  explicit IntBuilder(flatbuffers::FlatBufferBuilder& _fbb) : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Int> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Int>(end);
    return o;
  }
};

inline flatbuffers::Offset<Int> CreateInt(flatbuffers::FlatBufferBuilder& _fbb,
                                          int64_t value = 0) {
  IntBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct UInt FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef UIntBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  uint64_t value() const { return GetField<uint64_t>(VT_VALUE, 0); }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_VALUE) && verifier.EndTable();
  }
};

struct UIntBuilder {
  typedef UInt Table;
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(uint64_t value) {
    fbb_.AddElement<uint64_t>(UInt::VT_VALUE, value, 0);
  }
  explicit UIntBuilder(flatbuffers::FlatBufferBuilder& _fbb) : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<UInt> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UInt>(end);
    return o;
  }
};

inline flatbuffers::Offset<UInt> CreateUInt(
    flatbuffers::FlatBufferBuilder& _fbb, uint64_t value = 0) {
  UIntBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct Float FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FloatBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  float value() const { return GetField<float>(VT_VALUE, 0.0f); }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_VALUE) && verifier.EndTable();
  }
};

struct FloatBuilder {
  typedef Float Table;
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(float value) {
    fbb_.AddElement<float>(Float::VT_VALUE, value, 0.0f);
  }
  explicit FloatBuilder(flatbuffers::FlatBufferBuilder& _fbb) : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Float> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Float>(end);
    return o;
  }
};

inline flatbuffers::Offset<Float> CreateFloat(
    flatbuffers::FlatBufferBuilder& _fbb, float value = 0.0f) {
  FloatBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct Double FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DoubleBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4,
    VT_RULE = 6
  };
  double value() const { return GetField<double>(VT_VALUE, 0.0); }
  const touca::fbs::ComparisonRuleDouble* rule() const {
    return GetPointer<const touca::fbs::ComparisonRuleDouble*>(VT_RULE);
  }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_VALUE) &&
           VerifyOffset(verifier, VT_RULE) && verifier.VerifyTable(rule()) &&
           verifier.EndTable();
  }
};

struct DoubleBuilder {
  typedef Double Table;
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(double value) {
    fbb_.AddElement<double>(Double::VT_VALUE, value, 0.0);
  }
  void add_rule(flatbuffers::Offset<touca::fbs::ComparisonRuleDouble> rule) {
    fbb_.AddOffset(Double::VT_RULE, rule);
  }
  explicit DoubleBuilder(flatbuffers::FlatBufferBuilder& _fbb) : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Double> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Double>(end);
    return o;
  }
};

inline flatbuffers::Offset<Double> CreateDouble(
    flatbuffers::FlatBufferBuilder& _fbb, double value = 0.0,
    flatbuffers::Offset<touca::fbs::ComparisonRuleDouble> rule = 0) {
  DoubleBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_rule(rule);
  return builder_.Finish();
}

struct String FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StringBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  const flatbuffers::String* value() const {
    return GetPointer<const flatbuffers::String*>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyString(value()) && verifier.EndTable();
  }
};

struct StringBuilder {
  typedef String Table;
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(flatbuffers::Offset<flatbuffers::String> value) {
    fbb_.AddOffset(String::VT_VALUE, value);
  }
  explicit StringBuilder(flatbuffers::FlatBufferBuilder& _fbb) : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<String> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<String>(end);
    return o;
  }
};

inline flatbuffers::Offset<String> CreateString(
    flatbuffers::FlatBufferBuilder& _fbb,
    flatbuffers::Offset<flatbuffers::String> value = 0) {
  StringBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

inline flatbuffers::Offset<String> CreateStringDirect(
    flatbuffers::FlatBufferBuilder& _fbb, const char* value = nullptr) {
  auto value__ = value ? _fbb.CreateString(value) : 0;
  return touca::fbs::CreateString(_fbb, value__);
}

struct ObjectMember FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ObjectMemberBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_VALUE = 6
  };
  const flatbuffers::String* name() const {
    return GetPointer<const flatbuffers::String*>(VT_NAME);
  }
  const touca::fbs::TypeWrapper* value() const {
    return GetPointer<const touca::fbs::TypeWrapper*>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) && VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyTable(value()) && verifier.EndTable();
  }
};

struct ObjectMemberBuilder {
  typedef ObjectMember Table;
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(ObjectMember::VT_NAME, name);
  }
  void add_value(flatbuffers::Offset<touca::fbs::TypeWrapper> value) {
    fbb_.AddOffset(ObjectMember::VT_VALUE, value);
  }
  explicit ObjectMemberBuilder(flatbuffers::FlatBufferBuilder& _fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ObjectMember> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ObjectMember>(end);
    return o;
  }
};

inline flatbuffers::Offset<ObjectMember> CreateObjectMember(
    flatbuffers::FlatBufferBuilder& _fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<touca::fbs::TypeWrapper> value = 0) {
  ObjectMemberBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<ObjectMember> CreateObjectMemberDirect(
    flatbuffers::FlatBufferBuilder& _fbb, const char* name = nullptr,
    flatbuffers::Offset<touca::fbs::TypeWrapper> value = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return touca::fbs::CreateObjectMember(_fbb, name__, value);
}

struct Object FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ObjectBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KEY = 4,
    VT_VALUES = 6
  };
  const flatbuffers::String* key() const {
    return GetPointer<const flatbuffers::String*>(VT_KEY);
  }
  const flatbuffers::Vector<flatbuffers::Offset<touca::fbs::ObjectMember>>*
  values() const {
    return GetPointer<const flatbuffers::Vector<
        flatbuffers::Offset<touca::fbs::ObjectMember>>*>(VT_VALUES);
  }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_KEY) &&
           verifier.VerifyString(key()) && VerifyOffset(verifier, VT_VALUES) &&
           verifier.VerifyVector(values()) &&
           verifier.VerifyVectorOfTables(values()) && verifier.EndTable();
  }
};

struct ObjectBuilder {
  typedef Object Table;
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  void add_key(flatbuffers::Offset<flatbuffers::String> key) {
    fbb_.AddOffset(Object::VT_KEY, key);
  }
  void add_values(
      flatbuffers::Offset<
          flatbuffers::Vector<flatbuffers::Offset<touca::fbs::ObjectMember>>>
          values) {
    fbb_.AddOffset(Object::VT_VALUES, values);
  }
  explicit ObjectBuilder(flatbuffers::FlatBufferBuilder& _fbb) : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Object> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Object>(end);
    return o;
  }
};

inline flatbuffers::Offset<Object> CreateObject(
    flatbuffers::FlatBufferBuilder& _fbb,
    flatbuffers::Offset<flatbuffers::String> key = 0,
    flatbuffers::Offset<
        flatbuffers::Vector<flatbuffers::Offset<touca::fbs::ObjectMember>>>
        values = 0) {
  ObjectBuilder builder_(_fbb);
  builder_.add_values(values);
  builder_.add_key(key);
  return builder_.Finish();
}

inline flatbuffers::Offset<Object> CreateObjectDirect(
    flatbuffers::FlatBufferBuilder& _fbb, const char* key = nullptr,
    const std::vector<flatbuffers::Offset<touca::fbs::ObjectMember>>* values =
        nullptr) {
  auto key__ = key ? _fbb.CreateString(key) : 0;
  auto values__ =
      values ? _fbb.CreateVector<flatbuffers::Offset<touca::fbs::ObjectMember>>(
                   *values)
             : 0;
  return touca::fbs::CreateObject(_fbb, key__, values__);
}

struct Array FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ArrayBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUES = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<touca::fbs::TypeWrapper>>*
  values() const {
    return GetPointer<const flatbuffers::Vector<
        flatbuffers::Offset<touca::fbs::TypeWrapper>>*>(VT_VALUES);
  }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_VALUES) &&
           verifier.VerifyVector(values()) &&
           verifier.VerifyVectorOfTables(values()) && verifier.EndTable();
  }
};

struct ArrayBuilder {
  typedef Array Table;
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  void add_values(
      flatbuffers::Offset<
          flatbuffers::Vector<flatbuffers::Offset<touca::fbs::TypeWrapper>>>
          values) {
    fbb_.AddOffset(Array::VT_VALUES, values);
  }
  explicit ArrayBuilder(flatbuffers::FlatBufferBuilder& _fbb) : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Array> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Array>(end);
    return o;
  }
};

inline flatbuffers::Offset<Array> CreateArray(
    flatbuffers::FlatBufferBuilder& _fbb,
    flatbuffers::Offset<
        flatbuffers::Vector<flatbuffers::Offset<touca::fbs::TypeWrapper>>>
        values = 0) {
  ArrayBuilder builder_(_fbb);
  builder_.add_values(values);
  return builder_.Finish();
}

inline flatbuffers::Offset<Array> CreateArrayDirect(
    flatbuffers::FlatBufferBuilder& _fbb,
    const std::vector<flatbuffers::Offset<touca::fbs::TypeWrapper>>* values =
        nullptr) {
  auto values__ =
      values ? _fbb.CreateVector<flatbuffers::Offset<touca::fbs::TypeWrapper>>(
                   *values)
             : 0;
  return touca::fbs::CreateArray(_fbb, values__);
}

struct Blob FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BlobBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DIGEST = 4,
    VT_MIMETYPE = 6,
    VT_REFERENCE = 8
  };
  const flatbuffers::String* digest() const {
    return GetPointer<const flatbuffers::String*>(VT_DIGEST);
  }
  const flatbuffers::String* mimetype() const {
    return GetPointer<const flatbuffers::String*>(VT_MIMETYPE);
  }
  const flatbuffers::String* reference() const {
    return GetPointer<const flatbuffers::String*>(VT_REFERENCE);
  }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_DIGEST) &&
           verifier.VerifyString(digest()) &&
           VerifyOffset(verifier, VT_MIMETYPE) &&
           verifier.VerifyString(mimetype()) &&
           VerifyOffset(verifier, VT_REFERENCE) &&
           verifier.VerifyString(reference()) && verifier.EndTable();
  }
};

struct BlobBuilder {
  typedef Blob Table;
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  void add_digest(flatbuffers::Offset<flatbuffers::String> digest) {
    fbb_.AddOffset(Blob::VT_DIGEST, digest);
  }
  void add_mimetype(flatbuffers::Offset<flatbuffers::String> mimetype) {
    fbb_.AddOffset(Blob::VT_MIMETYPE, mimetype);
  }
  void add_reference(flatbuffers::Offset<flatbuffers::String> reference) {
    fbb_.AddOffset(Blob::VT_REFERENCE, reference);
  }
  explicit BlobBuilder(flatbuffers::FlatBufferBuilder& _fbb) : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Blob> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Blob>(end);
    return o;
  }
};

inline flatbuffers::Offset<Blob> CreateBlob(
    flatbuffers::FlatBufferBuilder& _fbb,
    flatbuffers::Offset<flatbuffers::String> digest = 0,
    flatbuffers::Offset<flatbuffers::String> mimetype = 0,
    flatbuffers::Offset<flatbuffers::String> reference = 0) {
  BlobBuilder builder_(_fbb);
  builder_.add_reference(reference);
  builder_.add_mimetype(mimetype);
  builder_.add_digest(digest);
  return builder_.Finish();
}

inline flatbuffers::Offset<Blob> CreateBlobDirect(
    flatbuffers::FlatBufferBuilder& _fbb, const char* digest = nullptr,
    const char* mimetype = nullptr, const char* reference = nullptr) {
  auto digest__ = digest ? _fbb.CreateString(digest) : 0;
  auto mimetype__ = mimetype ? _fbb.CreateString(mimetype) : 0;
  auto reference__ = reference ? _fbb.CreateString(reference) : 0;
  return touca::fbs::CreateBlob(_fbb, digest__, mimetype__, reference__);
}

struct Result FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ResultBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KEY = 4,
    VT_VALUE = 6,
    VT_TYP = 8
  };
  const flatbuffers::String* key() const {
    return GetPointer<const flatbuffers::String*>(VT_KEY);
  }
  const touca::fbs::TypeWrapper* value() const {
    return GetPointer<const touca::fbs::TypeWrapper*>(VT_VALUE);
  }
  touca::fbs::ResultType typ() const {
    return static_cast<touca::fbs::ResultType>(GetField<uint8_t>(VT_TYP, 1));
  }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_KEY) &&
           verifier.VerifyString(key()) && VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyTable(value()) &&
           VerifyField<uint8_t>(verifier, VT_TYP) && verifier.EndTable();
  }
};

struct ResultBuilder {
  typedef Result Table;
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  void add_key(flatbuffers::Offset<flatbuffers::String> key) {
    fbb_.AddOffset(Result::VT_KEY, key);
  }
  void add_value(flatbuffers::Offset<touca::fbs::TypeWrapper> value) {
    fbb_.AddOffset(Result::VT_VALUE, value);
  }
  void add_typ(touca::fbs::ResultType typ) {
    fbb_.AddElement<uint8_t>(Result::VT_TYP, static_cast<uint8_t>(typ), 1);
  }
  explicit ResultBuilder(flatbuffers::FlatBufferBuilder& _fbb) : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Result> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Result>(end);
    return o;
  }
};

inline flatbuffers::Offset<Result> CreateResult(
    flatbuffers::FlatBufferBuilder& _fbb,
    flatbuffers::Offset<flatbuffers::String> key = 0,
    flatbuffers::Offset<touca::fbs::TypeWrapper> value = 0,
    touca::fbs::ResultType typ = touca::fbs::ResultType::Check) {
  ResultBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_key(key);
  builder_.add_typ(typ);
  return builder_.Finish();
}

inline flatbuffers::Offset<Result> CreateResultDirect(
    flatbuffers::FlatBufferBuilder& _fbb, const char* key = nullptr,
    flatbuffers::Offset<touca::fbs::TypeWrapper> value = 0,
    touca::fbs::ResultType typ = touca::fbs::ResultType::Check) {
  auto key__ = key ? _fbb.CreateString(key) : 0;
  return touca::fbs::CreateResult(_fbb, key__, value, typ);
}

struct Assertion FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AssertionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {

  };
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
};

struct Metric FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MetricBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KEY = 4,
    VT_VALUE = 6
  };
  const flatbuffers::String* key() const {
    return GetPointer<const flatbuffers::String*>(VT_KEY);
  }
  const touca::fbs::TypeWrapper* value() const {
    return GetPointer<const touca::fbs::TypeWrapper*>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_KEY) &&
           verifier.VerifyString(key()) && VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyTable(value()) && verifier.EndTable();
  }
};

struct MetricBuilder {
  typedef Metric Table;
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  void add_key(flatbuffers::Offset<flatbuffers::String> key) {
    fbb_.AddOffset(Metric::VT_KEY, key);
  }
  void add_value(flatbuffers::Offset<touca::fbs::TypeWrapper> value) {
    fbb_.AddOffset(Metric::VT_VALUE, value);
  }
  explicit MetricBuilder(flatbuffers::FlatBufferBuilder& _fbb) : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Metric> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Metric>(end);
    return o;
  }
};

inline flatbuffers::Offset<Metric> CreateMetric(
    flatbuffers::FlatBufferBuilder& _fbb,
    flatbuffers::Offset<flatbuffers::String> key = 0,
    flatbuffers::Offset<touca::fbs::TypeWrapper> value = 0) {
  MetricBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_key(key);
  return builder_.Finish();
}

inline flatbuffers::Offset<Metric> CreateMetricDirect(
    flatbuffers::FlatBufferBuilder& _fbb, const char* key = nullptr,
    flatbuffers::Offset<touca::fbs::TypeWrapper> value = 0) {
  auto key__ = key ? _fbb.CreateString(key) : 0;
  return touca::fbs::CreateMetric(_fbb, key__, value);
}

struct Results FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ResultsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ENTRIES = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<touca::fbs::Result>>* entries()
      const {
    return GetPointer<
        const flatbuffers::Vector<flatbuffers::Offset<touca::fbs::Result>>*>(
        VT_ENTRIES);
  }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_ENTRIES) &&
           verifier.VerifyVector(entries()) &&
           verifier.VerifyVectorOfTables(entries()) && verifier.EndTable();
  }
};

struct ResultsBuilder {
  typedef Results Table;
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  void add_entries(flatbuffers::Offset<
                   flatbuffers::Vector<flatbuffers::Offset<touca::fbs::Result>>>
                       entries) {
    fbb_.AddOffset(Results::VT_ENTRIES, entries);
  }
  explicit ResultsBuilder(flatbuffers::FlatBufferBuilder& _fbb) : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Results> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Results>(end);
    return o;
  }
};

inline flatbuffers::Offset<Results> CreateResults(
    flatbuffers::FlatBufferBuilder& _fbb,
    flatbuffers::Offset<
        flatbuffers::Vector<flatbuffers::Offset<touca::fbs::Result>>>
        entries = 0) {
  ResultsBuilder builder_(_fbb);
  builder_.add_entries(entries);
  return builder_.Finish();
}

inline flatbuffers::Offset<Results> CreateResultsDirect(
    flatbuffers::FlatBufferBuilder& _fbb,
    const std::vector<flatbuffers::Offset<touca::fbs::Result>>* entries =
        nullptr) {
  auto entries__ =
      entries
          ? _fbb.CreateVector<flatbuffers::Offset<touca::fbs::Result>>(*entries)
          : 0;
  return touca::fbs::CreateResults(_fbb, entries__);
}

struct Assertions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AssertionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {

  };
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
};

struct Metrics FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MetricsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ENTRIES = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<touca::fbs::Metric>>* entries()
      const {
    return GetPointer<
        const flatbuffers::Vector<flatbuffers::Offset<touca::fbs::Metric>>*>(
        VT_ENTRIES);
  }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_ENTRIES) &&
           verifier.VerifyVector(entries()) &&
           verifier.VerifyVectorOfTables(entries()) && verifier.EndTable();
  }
};

struct MetricsBuilder {
  typedef Metrics Table;
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  void add_entries(flatbuffers::Offset<
                   flatbuffers::Vector<flatbuffers::Offset<touca::fbs::Metric>>>
                       entries) {
    fbb_.AddOffset(Metrics::VT_ENTRIES, entries);
  }
  explicit MetricsBuilder(flatbuffers::FlatBufferBuilder& _fbb) : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Metrics> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Metrics>(end);
    return o;
  }
};

inline flatbuffers::Offset<Metrics> CreateMetrics(
    flatbuffers::FlatBufferBuilder& _fbb,
    flatbuffers::Offset<
        flatbuffers::Vector<flatbuffers::Offset<touca::fbs::Metric>>>
        entries = 0) {
  MetricsBuilder builder_(_fbb);
  builder_.add_entries(entries);
  return builder_.Finish();
}

inline flatbuffers::Offset<Metrics> CreateMetricsDirect(
    flatbuffers::FlatBufferBuilder& _fbb,
    const std::vector<flatbuffers::Offset<touca::fbs::Metric>>* entries =
        nullptr) {
  auto entries__ =
      entries
          ? _fbb.CreateVector<flatbuffers::Offset<touca::fbs::Metric>>(*entries)
          : 0;
  return touca::fbs::CreateMetrics(_fbb, entries__);
}

struct Metadata FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MetadataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TESTSUITE = 4,
    VT_VERSION = 6,
    VT_TESTCASE = 10,
    VT_BUILTAT = 12,
    VT_TEAMSLUG = 14
  };
  const flatbuffers::String* testsuite() const {
    return GetPointer<const flatbuffers::String*>(VT_TESTSUITE);
  }
  const flatbuffers::String* version() const {
    return GetPointer<const flatbuffers::String*>(VT_VERSION);
  }
  const flatbuffers::String* testcase() const {
    return GetPointer<const flatbuffers::String*>(VT_TESTCASE);
  }
  const flatbuffers::String* builtAt() const {
    return GetPointer<const flatbuffers::String*>(VT_BUILTAT);
  }
  const flatbuffers::String* teamslug() const {
    return GetPointer<const flatbuffers::String*>(VT_TEAMSLUG);
  }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_TESTSUITE) &&
           verifier.VerifyString(testsuite()) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.VerifyString(version()) &&
           VerifyOffset(verifier, VT_TESTCASE) &&
           verifier.VerifyString(testcase()) &&
           VerifyOffset(verifier, VT_BUILTAT) &&
           verifier.VerifyString(builtAt()) &&
           VerifyOffset(verifier, VT_TEAMSLUG) &&
           verifier.VerifyString(teamslug()) && verifier.EndTable();
  }
};

struct MetadataBuilder {
  typedef Metadata Table;
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  void add_testsuite(flatbuffers::Offset<flatbuffers::String> testsuite) {
    fbb_.AddOffset(Metadata::VT_TESTSUITE, testsuite);
  }
  void add_version(flatbuffers::Offset<flatbuffers::String> version) {
    fbb_.AddOffset(Metadata::VT_VERSION, version);
  }
  void add_testcase(flatbuffers::Offset<flatbuffers::String> testcase) {
    fbb_.AddOffset(Metadata::VT_TESTCASE, testcase);
  }
  void add_builtAt(flatbuffers::Offset<flatbuffers::String> builtAt) {
    fbb_.AddOffset(Metadata::VT_BUILTAT, builtAt);
  }
  void add_teamslug(flatbuffers::Offset<flatbuffers::String> teamslug) {
    fbb_.AddOffset(Metadata::VT_TEAMSLUG, teamslug);
  }
  explicit MetadataBuilder(flatbuffers::FlatBufferBuilder& _fbb) : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Metadata> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Metadata>(end);
    return o;
  }
};

inline flatbuffers::Offset<Metadata> CreateMetadata(
    flatbuffers::FlatBufferBuilder& _fbb,
    flatbuffers::Offset<flatbuffers::String> testsuite = 0,
    flatbuffers::Offset<flatbuffers::String> version = 0,
    flatbuffers::Offset<flatbuffers::String> testcase = 0,
    flatbuffers::Offset<flatbuffers::String> builtAt = 0,
    flatbuffers::Offset<flatbuffers::String> teamslug = 0) {
  MetadataBuilder builder_(_fbb);
  builder_.add_teamslug(teamslug);
  builder_.add_builtAt(builtAt);
  builder_.add_testcase(testcase);
  builder_.add_version(version);
  builder_.add_testsuite(testsuite);
  return builder_.Finish();
}

inline flatbuffers::Offset<Metadata> CreateMetadataDirect(
    flatbuffers::FlatBufferBuilder& _fbb, const char* testsuite = nullptr,
    const char* version = nullptr, const char* testcase = nullptr,
    const char* builtAt = nullptr, const char* teamslug = nullptr) {
  auto testsuite__ = testsuite ? _fbb.CreateString(testsuite) : 0;
  auto version__ = version ? _fbb.CreateString(version) : 0;
  auto testcase__ = testcase ? _fbb.CreateString(testcase) : 0;
  auto builtAt__ = builtAt ? _fbb.CreateString(builtAt) : 0;
  auto teamslug__ = teamslug ? _fbb.CreateString(teamslug) : 0;
  return touca::fbs::CreateMetadata(_fbb, testsuite__, version__, testcase__,
                                    builtAt__, teamslug__);
}

struct Message FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_METADATA = 4,
    VT_RESULTS = 6,
    VT_METRICS = 10
  };
  const touca::fbs::Metadata* metadata() const {
    return GetPointer<const touca::fbs::Metadata*>(VT_METADATA);
  }
  const touca::fbs::Results* results() const {
    return GetPointer<const touca::fbs::Results*>(VT_RESULTS);
  }
  const touca::fbs::Metrics* metrics() const {
    return GetPointer<const touca::fbs::Metrics*>(VT_METRICS);
  }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_METADATA) &&
           verifier.VerifyTable(metadata()) &&
           VerifyOffset(verifier, VT_RESULTS) &&
           verifier.VerifyTable(results()) &&
           VerifyOffset(verifier, VT_METRICS) &&
           verifier.VerifyTable(metrics()) && verifier.EndTable();
  }
};

struct MessageBuilder {
  typedef Message Table;
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  void add_metadata(flatbuffers::Offset<touca::fbs::Metadata> metadata) {
    fbb_.AddOffset(Message::VT_METADATA, metadata);
  }
  void add_results(flatbuffers::Offset<touca::fbs::Results> results) {
    fbb_.AddOffset(Message::VT_RESULTS, results);
  }
  void add_metrics(flatbuffers::Offset<touca::fbs::Metrics> metrics) {
    fbb_.AddOffset(Message::VT_METRICS, metrics);
  }
  explicit MessageBuilder(flatbuffers::FlatBufferBuilder& _fbb) : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Message> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Message>(end);
    return o;
  }
};

inline flatbuffers::Offset<Message> CreateMessage(
    flatbuffers::FlatBufferBuilder& _fbb,
    flatbuffers::Offset<touca::fbs::Metadata> metadata = 0,
    flatbuffers::Offset<touca::fbs::Results> results = 0,
    flatbuffers::Offset<touca::fbs::Metrics> metrics = 0) {
  MessageBuilder builder_(_fbb);
  builder_.add_metrics(metrics);
  builder_.add_results(results);
  builder_.add_metadata(metadata);
  return builder_.Finish();
}

struct MessageBuffer FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MessageBufferBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BUF = 4
  };
  const flatbuffers::Vector<uint8_t>* buf() const {
    return GetPointer<const flatbuffers::Vector<uint8_t>*>(VT_BUF);
  }
  const touca::fbs::Message* buf_nested_root() const {
    return flatbuffers::GetRoot<touca::fbs::Message>(buf()->Data());
  }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_BUF) &&
           verifier.VerifyVector(buf()) && verifier.EndTable();
  }
};

struct MessageBufferBuilder {
  typedef MessageBuffer Table;
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  void add_buf(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> buf) {
    fbb_.AddOffset(MessageBuffer::VT_BUF, buf);
  }
  explicit MessageBufferBuilder(flatbuffers::FlatBufferBuilder& _fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MessageBuffer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MessageBuffer>(end);
    return o;
  }
};

inline flatbuffers::Offset<MessageBuffer> CreateMessageBuffer(
    flatbuffers::FlatBufferBuilder& _fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> buf = 0) {
  MessageBufferBuilder builder_(_fbb);
  builder_.add_buf(buf);
  return builder_.Finish();
}

inline flatbuffers::Offset<MessageBuffer> CreateMessageBufferDirect(
    flatbuffers::FlatBufferBuilder& _fbb,
    const std::vector<uint8_t>* buf = nullptr) {
  auto buf__ = buf ? _fbb.CreateVector<uint8_t>(*buf) : 0;
  return touca::fbs::CreateMessageBuffer(_fbb, buf__);
}

struct Messages FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MessagesBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MESSAGES = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<touca::fbs::MessageBuffer>>*
  messages() const {
    return GetPointer<const flatbuffers::Vector<
        flatbuffers::Offset<touca::fbs::MessageBuffer>>*>(VT_MESSAGES);
  }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_MESSAGES) &&
           verifier.VerifyVector(messages()) &&
           verifier.VerifyVectorOfTables(messages()) && verifier.EndTable();
  }
};

struct MessagesBuilder {
  typedef Messages Table;
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  void add_messages(
      flatbuffers::Offset<
          flatbuffers::Vector<flatbuffers::Offset<touca::fbs::MessageBuffer>>>
          messages) {
    fbb_.AddOffset(Messages::VT_MESSAGES, messages);
  }
  explicit MessagesBuilder(flatbuffers::FlatBufferBuilder& _fbb) : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Messages> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Messages>(end);
    return o;
  }
};

inline flatbuffers::Offset<Messages> CreateMessages(
    flatbuffers::FlatBufferBuilder& _fbb,
    flatbuffers::Offset<
        flatbuffers::Vector<flatbuffers::Offset<touca::fbs::MessageBuffer>>>
        messages = 0) {
  MessagesBuilder builder_(_fbb);
  builder_.add_messages(messages);
  return builder_.Finish();
}

inline flatbuffers::Offset<Messages> CreateMessagesDirect(
    flatbuffers::FlatBufferBuilder& _fbb,
    const std::vector<flatbuffers::Offset<touca::fbs::MessageBuffer>>*
        messages = nullptr) {
  auto messages__ =
      messages
          ? _fbb.CreateVector<flatbuffers::Offset<touca::fbs::MessageBuffer>>(
                *messages)
          : 0;
  return touca::fbs::CreateMessages(_fbb, messages__);
}

inline bool VerifyType(flatbuffers::Verifier& verifier, const void* obj,
                       Type type) {
  switch (type) {
    case Type::NONE: {
      return true;
    }
    case Type::Bool: {
      auto ptr = reinterpret_cast<const touca::fbs::Bool*>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Type::Int: {
      auto ptr = reinterpret_cast<const touca::fbs::Int*>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Type::UInt: {
      auto ptr = reinterpret_cast<const touca::fbs::UInt*>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Type::Float: {
      auto ptr = reinterpret_cast<const touca::fbs::Float*>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Type::Double: {
      auto ptr = reinterpret_cast<const touca::fbs::Double*>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Type::String: {
      auto ptr = reinterpret_cast<const touca::fbs::String*>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Type::Object: {
      auto ptr = reinterpret_cast<const touca::fbs::Object*>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Type::Array: {
      auto ptr = reinterpret_cast<const touca::fbs::Array*>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Type::Blob: {
      auto ptr = reinterpret_cast<const touca::fbs::Blob*>(obj);
      return verifier.VerifyTable(ptr);
    }
    default:
      return true;
  }
}

inline bool VerifyTypeVector(
    flatbuffers::Verifier& verifier,
    const flatbuffers::Vector<flatbuffers::Offset<void>>* values,
    const flatbuffers::Vector<Type>* types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyType(verifier, values->Get(i), types->GetEnum<Type>(i))) {
      return false;
    }
  }
  return true;
}

inline const touca::fbs::Messages* GetMessages(const void* buf) {
  return flatbuffers::GetRoot<touca::fbs::Messages>(buf);
}

inline const touca::fbs::Messages* GetSizePrefixedMessages(const void* buf) {
  return flatbuffers::GetSizePrefixedRoot<touca::fbs::Messages>(buf);
}

inline bool VerifyMessagesBuffer(flatbuffers::Verifier& verifier) {
  return verifier.VerifyBuffer<touca::fbs::Messages>(nullptr);
}

inline bool VerifySizePrefixedMessagesBuffer(flatbuffers::Verifier& verifier) {
  return verifier.VerifySizePrefixedBuffer<touca::fbs::Messages>(nullptr);
}

inline void FinishMessagesBuffer(
    flatbuffers::FlatBufferBuilder& fbb,
    flatbuffers::Offset<touca::fbs::Messages> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedMessagesBuffer(
    flatbuffers::FlatBufferBuilder& fbb,
    flatbuffers::Offset<touca::fbs::Messages> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace fbs
}  // namespace touca
