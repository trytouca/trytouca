# Tutorials

Previously, we learned how to build a Regression Test Tool for a trivial
Code Under Test using the Weasel Client Library for C++. The Library is
designed to be low-level and extensible enough to allow us to extend that
pattern to test any Workflow of arbitrary complexity. But as we build more
Test Tools, we learn that our Test Tools share many similarities in structure
and common features.

To reduce possible code duplications and enable code reuse, Weasel provides
a separate Test Framework for C++ with a modular and extensible design.
By implementing common features, the Test Framework can unify the behavior
and the code structure of our Test Tools to make developing and maintaining
them less consuming.

In this document, we demonstrate some of the capabilities of this Test
Framework by building a new Regression Test Tool for the same trivial
Code Under Test that we used in the "Getting Started" page.

## Using Weasel Test Framework

### Common Features

Weasel Test Framework is designed to help engineers focus on implementing the
test execution workflow of a given Test Case by abstracting away the common
features of Regression Test Tools. Some of these common features are listed
below.

* Parsing Command Line Arguments

  The Framework already supports many useful command-line options out of the
  box and makes it easy to add and parse extra workflow-specific options.

* Parsing Configuration Files

  The Framework already supports extracting configuration parameters from a
  separate configuration file.

* Initializing Workflow-Specific Resources

  Engineers can easily define and configure any resources related to the
  Code Under Test, such as Log Files, helper classes etc.

* Extraction of Log Events

  Engineers can extract the log events generated by the Framework
  and redirect them to their own logger.

* Managing List of Test Cases

  The Framework allows engineers to create reusable Test Suites with custom
  logic for extracting the list of Test Cases. It also offers several
  plug-and-play Test Suites that can obtain the list of Test Cases from the
  Weasel Platform or by parsing a given file.

* Capturing Output of Code Under Test

  The Framework redirects any content written to standard output or standard
  error when executing the Code Under Test to separate files for easier
  inspection and post-processing.

* Managing Data Storage on Filesystem

  The Framework can create and maintain a directory hierarchy in which Result
  files, log files, and other Workflow-specific files can be stored based on
  the names of the Workflow, Revision, and Test Case that are executed.

* Skipping Already Executed Test Cases

  The Framework allows engineers to specify the conditions in which a given
  Test Case should be skipped for a particular Revision of the Code Under Test.

* Reporting Execution Progress

  For each executed Test Case, the Framework reports the name of the Test Case,
  its execution runtime, and any error that it may have produced.

* Handling Errors and Exceptions

  The Framework catches and reports any returned error or thrown exception of
  the Code Under Test to help ensure the failure of a given Test Case does not
  disrupt the overall test process.

* Integrating with the Weasel Client Library

  The Framework automatically calls the lower-level Weasel Client functions
  following all the recommended best practices. It configures the Weasel
  Client, declares Test Cases, submits test Results, etc. It allows engineers
  to disable any interaction with the Weasel Platform if they so choose.

### The Main Function

Weasel Test Framework has an entry-point `weasel::framework::main` that is
meant to be called from the main function of our Test Tool using the following
pattern.

```cpp
int main(int argc, char* argv[])
{
    MyWorkflow workflow;
    return weasel::framework::main(argc, argv, workflow);
}
```

This function takes over running our application for any given Workflow.
In the example above, MyWorkflow is a class derived from the abstract class
`weasel::framework::Workflow`.

### The Workflow Class

The Workflow Class helps us describe our Test Workflow. It encapsulates any
logic that distinguishes our Test Tool from other Regression Test Tools.
This class is given to the `main` function of the Test Framework that calls
its different member functions in a specific order. Most member functions
have a trivial default implementation that gives the engineers the option
to override them and provide their own custom code.

See our Reference API documentation for a complete list of the member functions
of the Workflow class and the order in which they are called.

There are two member function that *must* be implemented:

* `Workflow::execute` is meant to describe how a particular Test Case should
  be executed. This is the function that we override to pass our Test Cases
  to the Code Under Test.

  In the `is_prime` example that we reviewed in the `Getting Started` document,
  the following code snippet may serve as a possible implementation of this
  function.

  ```cpp
  weasel::framework::Errors execute(
    const weasel::framework::Testcase& testcase) const override
  {
      const auto input_number = std::stoul(testcase);
      weasel::add_assertion("input_number", input_number);
      weasel::start_timer("overall runtime");
      weasel::add_result("is_prime", is_prime(input_number));
      weasel::stop_timer("overall runtime");
      return {};
  }
  ```

* `Workflow::suite` is meant to describe how a list of our Test Cases should
  be obtained when we run the Test Tool. Since many test tools may use the
  same approach to obtain this list, we describe this logic in a separate
  instance of the `Suite` class.

### The Suite Class

Weasel Test Framework allows us to formulate how the list of our Test Cases
should be obtained by deriving from class `weasel::framework::Suite`.

In our `is_prime` example, we used a list of eight numbers as our set of
inputs to the Code Under Test.
The following code snippet shows one way to represent this list by deriving
from the Suite class:

```cpp
class MySuite final : public weasel::framework::Suite
{
public:
    MySuite() : Suite()
    {
        for (const auto number: { 1, 2, 3, 4, 7, 673, 7453, 14747 })
        {
            push(std::to_string(number));
        }
    }
};
```

Then we can use this class to implement `Workflow::suite`:

```cpp
std::shared_ptr<weasel::framework::Suite> suite() const override
{
    return std::make_shared<MySuite>();
}
```

But as we mentioned in the "Getting Started" document, it is helpful to ensure
that the list of Test Cases can be modified without the need to rebuild our
Test Tool. One way to do so is to list our Test Case in an
external file to be read and parsed at runtime.

Weasel provides a few prepared implementations of the `Suite` class. One of
these available implementations is the `FileSuite` that can help achieve our
goal:

```cpp
std::shared_ptr<weasel::framework::Suite> suite() const override
{
    return std::make_shared<weasel::framework::FileSuite>("suite.txt");
}
```

### The Final Test Tool

Putting things together, the code snippet below shows a basic implementation
for our Regression Test Tool using Weasel Test Framework for C++.

```cpp
/**
 * @file regression_test.hpp
 */

#include "code_under_test.hpp"
#include "weasel/weasel.hpp"
#include "weasel/framework.hpp"
#include "weasel/framework/suites.hpp"

namespace wf = weasel::framework;

class MyWorkflow : public wf::Workflow
{
public:
    std::shared_ptr<wf::Suite> suite() const override
    {
        return std::make_shared<wf::FileSuite>("suite.txt");
    }

    wf::Errors execute(const wf::Testcase& testcase) const override
    {
        const auto input_number = std::stoul(testcase);
        weasel::add_assertion("input_number", input_number);
        weasel::start_timer("overall runtime");
        weasel::add_result("is_prime", is_prime(input_number));
        weasel::stop_timer("overall runtime");
        return {};
    }
};

int main(int argc, char* argv[])
{
    MyWorkflow workflow;
    return wf::main(argc, argv, workflow);
}
```

We can test any Revision of the Code Under Test by passing command-line options
`--revision` and `--config-file` as shown below:

```bash
$ ./regression_test -c ./config.json -r 1.0
```

Where `config.json` may have the following content:

```json
{
  "framework": {
    "output-dir": "./output",
    "save-as-binary": "true",
    "save-as-json": "false"
  },
  "weasel": {
    "api-key": "0eb962f2-84cd-4a01-9721-c339dc335972",
    "api-url": "https://getweasel.com/api/@/myteam/is_prime"
  }
}
```

And `suite.txt` simply lists our Test Cases:

```none
1
2
3
4
7
673
7453
14747
```

We can expect the test to produce an output similar to what is shown below:

```none

Weasel Regression Test Framework
Suite: is_prime
Revision: 1.0

 (  1 of 8  ) 1                                (pass, 0 ms)
 (  2 of 8  ) 2                                (pass, 0 ms)
 (  3 of 8  ) 3                                (pass, 0 ms)
 (  4 of 8  ) 4                                (pass, 0 ms)
 (  5 of 8  ) 7                                (pass, 0 ms)
 (  6 of 8  ) 673                              (pass, 0 ms)
 (  7 of 8  ) 745                              (pass, 0 ms)
 (  8 of 8  ) 14747                            (pass, 0 ms)

processed 8 of 8 testcases
test completed in 0 ms

```

### Customizing

Weasel Test Framework allows us to provide a custom implementation for the
member functions of the Workflow class. The set of supported configuration
options are also customizable. In this section, we briefly demonstrate how
these features can be used.

The example provided in the previous section extracts the list of Test Cases
from a text file with a fixed filename `suite.txt`. Let us try to make this
filename configurable.

One way to make this file configurable is to add it to the list of
configuration parameters specified in our application configuration file.

```json
{
  "framework": {
    "output-dir": "./output",
    "save-as-binary": "true",
    "save-as-json": "false"
  },
  "weasel": {
    "api-key": "0eb962f2-84cd-4a01-9721-c339dc335972",
    "api-url": "https://getweasel.com/api/@/myteam/is_prime"
  },
  "workflow": {
    "suite-file": "./suite.txt"
  }
}
```

Doing so makes this configuration parameter available in any member function
of the `Workflow` class through the `_options` member variable. This allows
us to change the implementation of member function `suite()` to the following:

```cpp
std::shared_ptr<wf::Suite> suite() const override
{
    return std::make_shared<wf::FileSuite>(_options.at("suite-file"));
}
```

This change makes `suite-file` a required configuration option. We can make
ensure that this option is always provided by implementing the member function
`Workflow::validate_options`.

```cpp
bool validate_options() const override
{
    return _options.count("suite-file");
}
```

If we decide to declare this parameter as a command-line option, it suffices
that we implement the member function `Workflow::parse_options` and append
the value parsed from the command line arguments to the member variable
`_options` by calling `Workflow::add_option`. If we do so, it also makes sense
to implement `Workflow::describe_options` to provide a simple string that is
shown to the user if they run the Test Tool with the option `--help`.
