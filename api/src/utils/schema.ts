/* eslint-disable @typescript-eslint/no-non-null-assertion */
// automatically generated by the FlatBuffers compiler, do not modify

import * as flatbuffers from 'flatbuffers'

export enum Type {
  NONE = 0,
  Bool = 1,
  Int = 2,
  UInt = 3,
  Float = 4,
  Double = 5,
  String = 6,
  Object = 7,
  Array = 8
}

export enum ResultType {
  Check = 1,
  Assert = 2
}

export class TypeWrapper {
  bb: flatbuffers.ByteBuffer | null = null
  bb_pos = 0
  __init(i: number, bb: flatbuffers.ByteBuffer): TypeWrapper {
    this.bb_pos = i
    this.bb = bb
    return this
  }

  static getRootAsTypeWrapper(
    bb: flatbuffers.ByteBuffer,
    obj?: TypeWrapper
  ): TypeWrapper {
    return (obj || new TypeWrapper()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    )
  }

  static getSizePrefixedRootAsTypeWrapper(
    bb: flatbuffers.ByteBuffer,
    obj?: TypeWrapper
  ): TypeWrapper {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH)
    return (obj || new TypeWrapper()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    )
  }

  valueType(): Type {
    const offset = this.bb!.__offset(this.bb_pos, 4)
    return offset ? this.bb!.readUint8(this.bb_pos + offset) : Type.NONE
  }

  value<T extends flatbuffers.Table>(obj: any): any | null {
    const offset = this.bb!.__offset(this.bb_pos, 6)
    return offset ? this.bb!.__union(obj, this.bb_pos + offset) : null
  }

  static startTypeWrapper(builder: flatbuffers.Builder) {
    builder.startObject(2)
  }

  static addValueType(builder: flatbuffers.Builder, valueType: Type) {
    builder.addFieldInt8(0, valueType, Type.NONE)
  }

  static addValue(
    builder: flatbuffers.Builder,
    valueOffset: flatbuffers.Offset
  ) {
    builder.addFieldOffset(1, valueOffset, 0)
  }

  static endTypeWrapper(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject()
    return offset
  }

  static createTypeWrapper(
    builder: flatbuffers.Builder,
    valueType: Type,
    valueOffset: flatbuffers.Offset
  ): flatbuffers.Offset {
    TypeWrapper.startTypeWrapper(builder)
    TypeWrapper.addValueType(builder, valueType)
    TypeWrapper.addValue(builder, valueOffset)
    return TypeWrapper.endTypeWrapper(builder)
  }
}

export class Bool {
  bb: flatbuffers.ByteBuffer | null = null
  bb_pos = 0
  __init(i: number, bb: flatbuffers.ByteBuffer): Bool {
    this.bb_pos = i
    this.bb = bb
    return this
  }

  static getRootAsBool(bb: flatbuffers.ByteBuffer, obj?: Bool): Bool {
    return (obj || new Bool()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    )
  }

  static getSizePrefixedRootAsBool(
    bb: flatbuffers.ByteBuffer,
    obj?: Bool
  ): Bool {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH)
    return (obj || new Bool()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    )
  }

  value(): boolean {
    const offset = this.bb!.__offset(this.bb_pos, 4)
    return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false
  }

  static startBool(builder: flatbuffers.Builder) {
    builder.startObject(1)
  }

  static addValue(builder: flatbuffers.Builder, value: boolean) {
    builder.addFieldInt8(0, +value, +false)
  }

  static endBool(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject()
    return offset
  }

  static createBool(
    builder: flatbuffers.Builder,
    value: boolean
  ): flatbuffers.Offset {
    Bool.startBool(builder)
    Bool.addValue(builder, value)
    return Bool.endBool(builder)
  }
}

export class Double {
  bb: flatbuffers.ByteBuffer | null = null
  bb_pos = 0
  __init(i: number, bb: flatbuffers.ByteBuffer): Double {
    this.bb_pos = i
    this.bb = bb
    return this
  }

  static getRootAsDouble(bb: flatbuffers.ByteBuffer, obj?: Double): Double {
    return (obj || new Double()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    )
  }

  static getSizePrefixedRootAsDouble(
    bb: flatbuffers.ByteBuffer,
    obj?: Double
  ): Double {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH)
    return (obj || new Double()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    )
  }

  value(): number {
    const offset = this.bb!.__offset(this.bb_pos, 4)
    return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0
  }

  static startDouble(builder: flatbuffers.Builder) {
    builder.startObject(1)
  }

  static addValue(builder: flatbuffers.Builder, value: number) {
    builder.addFieldFloat64(0, value, 0.0)
  }

  static endDouble(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject()
    return offset
  }

  static createDouble(
    builder: flatbuffers.Builder,
    value: number
  ): flatbuffers.Offset {
    Double.startDouble(builder)
    Double.addValue(builder, value)
    return Double.endDouble(builder)
  }
}

export class Float {
  bb: flatbuffers.ByteBuffer | null = null
  bb_pos = 0
  __init(i: number, bb: flatbuffers.ByteBuffer): Float {
    this.bb_pos = i
    this.bb = bb
    return this
  }

  static getRootAsFloat(bb: flatbuffers.ByteBuffer, obj?: Float): Float {
    return (obj || new Float()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    )
  }

  static getSizePrefixedRootAsFloat(
    bb: flatbuffers.ByteBuffer,
    obj?: Float
  ): Float {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH)
    return (obj || new Float()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    )
  }

  value(): number {
    const offset = this.bb!.__offset(this.bb_pos, 4)
    return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0
  }

  static startFloat(builder: flatbuffers.Builder) {
    builder.startObject(1)
  }

  static addValue(builder: flatbuffers.Builder, value: number) {
    builder.addFieldFloat32(0, value, 0.0)
  }

  static endFloat(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject()
    return offset
  }

  static createFloat(
    builder: flatbuffers.Builder,
    value: number
  ): flatbuffers.Offset {
    Float.startFloat(builder)
    Float.addValue(builder, value)
    return Float.endFloat(builder)
  }
}

export class Int {
  bb: flatbuffers.ByteBuffer | null = null
  bb_pos = 0
  __init(i: number, bb: flatbuffers.ByteBuffer): Int {
    this.bb_pos = i
    this.bb = bb
    return this
  }

  static getRootAsInt(bb: flatbuffers.ByteBuffer, obj?: Int): Int {
    return (obj || new Int()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    )
  }

  static getSizePrefixedRootAsInt(bb: flatbuffers.ByteBuffer, obj?: Int): Int {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH)
    return (obj || new Int()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    )
  }

  value(): flatbuffers.Long {
    const offset = this.bb!.__offset(this.bb_pos, 4)
    return offset
      ? this.bb!.readInt64(this.bb_pos + offset)
      : this.bb!.createLong(0, 0)
  }

  static startInt(builder: flatbuffers.Builder) {
    builder.startObject(1)
  }

  static addValue(builder: flatbuffers.Builder, value: flatbuffers.Long) {
    builder.addFieldInt64(0, value, builder.createLong(0, 0))
  }

  static endInt(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject()
    return offset
  }

  static createInt(
    builder: flatbuffers.Builder,
    value: flatbuffers.Long
  ): flatbuffers.Offset {
    Int.startInt(builder)
    Int.addValue(builder, value)
    return Int.endInt(builder)
  }
}

export class UInt {
  bb: flatbuffers.ByteBuffer | null = null
  bb_pos = 0
  __init(i: number, bb: flatbuffers.ByteBuffer): UInt {
    this.bb_pos = i
    this.bb = bb
    return this
  }

  static getRootAsUInt(bb: flatbuffers.ByteBuffer, obj?: UInt): UInt {
    return (obj || new UInt()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    )
  }

  static getSizePrefixedRootAsUInt(
    bb: flatbuffers.ByteBuffer,
    obj?: UInt
  ): UInt {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH)
    return (obj || new UInt()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    )
  }

  value(): flatbuffers.Long {
    const offset = this.bb!.__offset(this.bb_pos, 4)
    return offset
      ? this.bb!.readUint64(this.bb_pos + offset)
      : this.bb!.createLong(0, 0)
  }

  static startUInt(builder: flatbuffers.Builder) {
    builder.startObject(1)
  }

  static addValue(builder: flatbuffers.Builder, value: flatbuffers.Long) {
    builder.addFieldInt64(0, value, builder.createLong(0, 0))
  }

  static endUInt(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject()
    return offset
  }

  static createUInt(
    builder: flatbuffers.Builder,
    value: flatbuffers.Long
  ): flatbuffers.Offset {
    UInt.startUInt(builder)
    UInt.addValue(builder, value)
    return UInt.endUInt(builder)
  }
}

export class T_String {
  bb: flatbuffers.ByteBuffer | null = null
  bb_pos = 0
  __init(i: number, bb: flatbuffers.ByteBuffer): T_String {
    this.bb_pos = i
    this.bb = bb
    return this
  }

  static getRootAsString(bb: flatbuffers.ByteBuffer, obj?: T_String): T_String {
    return (obj || new T_String()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    )
  }

  static getSizePrefixedRootAsString(
    bb: flatbuffers.ByteBuffer,
    obj?: T_String
  ): T_String {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH)
    return (obj || new T_String()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    )
  }

  value(): string | null
  value(optionalEncoding: flatbuffers.Encoding): string | Uint8Array | null
  value(optionalEncoding?: any): string | Uint8Array | null {
    const offset = this.bb!.__offset(this.bb_pos, 4)
    return offset
      ? this.bb!.__string(this.bb_pos + offset, optionalEncoding)
      : null
  }

  static startString(builder: flatbuffers.Builder) {
    builder.startObject(1)
  }

  static addValue(
    builder: flatbuffers.Builder,
    valueOffset: flatbuffers.Offset
  ) {
    builder.addFieldOffset(0, valueOffset, 0)
  }

  static endString(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject()
    return offset
  }

  static createString(
    builder: flatbuffers.Builder,
    valueOffset: flatbuffers.Offset
  ): flatbuffers.Offset {
    T_String.startString(builder)
    T_String.addValue(builder, valueOffset)
    return T_String.endString(builder)
  }
}

export class ObjectMember {
  bb: flatbuffers.ByteBuffer | null = null
  bb_pos = 0
  __init(i: number, bb: flatbuffers.ByteBuffer): ObjectMember {
    this.bb_pos = i
    this.bb = bb
    return this
  }

  static getRootAsObjectMember(
    bb: flatbuffers.ByteBuffer,
    obj?: ObjectMember
  ): ObjectMember {
    return (obj || new ObjectMember()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    )
  }

  static getSizePrefixedRootAsObjectMember(
    bb: flatbuffers.ByteBuffer,
    obj?: ObjectMember
  ): ObjectMember {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH)
    return (obj || new ObjectMember()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    )
  }

  name(): string | null
  name(optionalEncoding: flatbuffers.Encoding): string | Uint8Array | null
  name(optionalEncoding?: any): string | Uint8Array | null {
    const offset = this.bb!.__offset(this.bb_pos, 4)
    return offset
      ? this.bb!.__string(this.bb_pos + offset, optionalEncoding)
      : null
  }

  value(obj?: TypeWrapper): TypeWrapper | null {
    const offset = this.bb!.__offset(this.bb_pos, 6)
    return offset
      ? (obj || new TypeWrapper()).__init(
          this.bb!.__indirect(this.bb_pos + offset),
          this.bb!
        )
      : null
  }

  static startObjectMember(builder: flatbuffers.Builder) {
    builder.startObject(2)
  }

  static addName(builder: flatbuffers.Builder, nameOffset: flatbuffers.Offset) {
    builder.addFieldOffset(0, nameOffset, 0)
  }

  static addValue(
    builder: flatbuffers.Builder,
    valueOffset: flatbuffers.Offset
  ) {
    builder.addFieldOffset(1, valueOffset, 0)
  }

  static endObjectMember(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject()
    return offset
  }
}

export class T_Object {
  bb: flatbuffers.ByteBuffer | null = null
  bb_pos = 0
  __init(i: number, bb: flatbuffers.ByteBuffer): T_Object {
    this.bb_pos = i
    this.bb = bb
    return this
  }

  static getRootAsObject(bb: flatbuffers.ByteBuffer, obj?: T_Object): T_Object {
    return (obj || new T_Object()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    )
  }

  static getSizePrefixedRootAsObject(
    bb: flatbuffers.ByteBuffer,
    obj?: T_Object
  ): T_Object {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH)
    return (obj || new T_Object()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    )
  }

  key(): string | null
  key(optionalEncoding: flatbuffers.Encoding): string | Uint8Array | null
  key(optionalEncoding?: any): string | Uint8Array | null {
    const offset = this.bb!.__offset(this.bb_pos, 4)
    return offset
      ? this.bb!.__string(this.bb_pos + offset, optionalEncoding)
      : null
  }

  values(index: number, obj?: ObjectMember): ObjectMember | null {
    const offset = this.bb!.__offset(this.bb_pos, 6)
    return offset
      ? (obj || new ObjectMember()).__init(
          this.bb!.__indirect(
            this.bb!.__vector(this.bb_pos + offset) + index * 4
          ),
          this.bb!
        )
      : null
  }

  valuesLength(): number {
    const offset = this.bb!.__offset(this.bb_pos, 6)
    return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0
  }

  static startObject(builder: flatbuffers.Builder) {
    builder.startObject(2)
  }

  static addKey(builder: flatbuffers.Builder, keyOffset: flatbuffers.Offset) {
    builder.addFieldOffset(0, keyOffset, 0)
  }

  static addValues(
    builder: flatbuffers.Builder,
    valuesOffset: flatbuffers.Offset
  ) {
    builder.addFieldOffset(1, valuesOffset, 0)
  }

  static createValuesVector(
    builder: flatbuffers.Builder,
    data: flatbuffers.Offset[]
  ): flatbuffers.Offset {
    builder.startVector(4, data.length, 4)
    for (let i = data.length - 1; i >= 0; i--) {
      builder.addOffset(data[i]!)
    }
    return builder.endVector()
  }

  static startValuesVector(builder: flatbuffers.Builder, numElems: number) {
    builder.startVector(4, numElems, 4)
  }

  static endObject(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject()
    return offset
  }

  static createObject(
    builder: flatbuffers.Builder,
    keyOffset: flatbuffers.Offset,
    valuesOffset: flatbuffers.Offset
  ): flatbuffers.Offset {
    T_Object.startObject(builder)
    T_Object.addKey(builder, keyOffset)
    T_Object.addValues(builder, valuesOffset)
    return T_Object.endObject(builder)
  }
}

export class T_Array {
  bb: flatbuffers.ByteBuffer | null = null
  bb_pos = 0
  __init(i: number, bb: flatbuffers.ByteBuffer): T_Array {
    this.bb_pos = i
    this.bb = bb
    return this
  }

  static getRootAsArray(bb: flatbuffers.ByteBuffer, obj?: T_Array): T_Array {
    return (obj || new T_Array()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    )
  }

  static getSizePrefixedRootAsArray(
    bb: flatbuffers.ByteBuffer,
    obj?: T_Array
  ): T_Array {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH)
    return (obj || new T_Array()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    )
  }

  values(index: number, obj?: TypeWrapper): TypeWrapper | null {
    const offset = this.bb!.__offset(this.bb_pos, 4)
    return offset
      ? (obj || new TypeWrapper()).__init(
          this.bb!.__indirect(
            this.bb!.__vector(this.bb_pos + offset) + index * 4
          ),
          this.bb!
        )
      : null
  }

  valuesLength(): number {
    const offset = this.bb!.__offset(this.bb_pos, 4)
    return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0
  }

  static startArray(builder: flatbuffers.Builder) {
    builder.startObject(1)
  }

  static addValues(
    builder: flatbuffers.Builder,
    valuesOffset: flatbuffers.Offset
  ) {
    builder.addFieldOffset(0, valuesOffset, 0)
  }

  static createValuesVector(
    builder: flatbuffers.Builder,
    data: flatbuffers.Offset[]
  ): flatbuffers.Offset {
    builder.startVector(4, data.length, 4)
    for (let i = data.length - 1; i >= 0; i--) {
      builder.addOffset(data[i]!)
    }
    return builder.endVector()
  }

  static startValuesVector(builder: flatbuffers.Builder, numElems: number) {
    builder.startVector(4, numElems, 4)
  }

  static endArray(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject()
    return offset
  }

  static createArray(
    builder: flatbuffers.Builder,
    valuesOffset: flatbuffers.Offset
  ): flatbuffers.Offset {
    T_Array.startArray(builder)
    T_Array.addValues(builder, valuesOffset)
    return T_Array.endArray(builder)
  }
}

export class Result {
  bb: flatbuffers.ByteBuffer | null = null
  bb_pos = 0
  __init(i: number, bb: flatbuffers.ByteBuffer): Result {
    this.bb_pos = i
    this.bb = bb
    return this
  }

  static getRootAsResult(bb: flatbuffers.ByteBuffer, obj?: Result): Result {
    return (obj || new Result()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    )
  }

  static getSizePrefixedRootAsResult(
    bb: flatbuffers.ByteBuffer,
    obj?: Result
  ): Result {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH)
    return (obj || new Result()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    )
  }

  key(): string | null
  key(optionalEncoding: flatbuffers.Encoding): string | Uint8Array | null
  key(optionalEncoding?: any): string | Uint8Array | null {
    const offset = this.bb!.__offset(this.bb_pos, 4)
    return offset
      ? this.bb!.__string(this.bb_pos + offset, optionalEncoding)
      : null
  }

  value(obj?: TypeWrapper): TypeWrapper | null {
    const offset = this.bb!.__offset(this.bb_pos, 6)
    return offset
      ? (obj || new TypeWrapper()).__init(
          this.bb!.__indirect(this.bb_pos + offset),
          this.bb!
        )
      : null
  }

  typ(): ResultType {
    const offset = this.bb!.__offset(this.bb_pos, 8)
    return offset ? this.bb!.readUint8(this.bb_pos + offset) : ResultType.Check
  }

  static startResult(builder: flatbuffers.Builder) {
    builder.startObject(3)
  }

  static addKey(builder: flatbuffers.Builder, keyOffset: flatbuffers.Offset) {
    builder.addFieldOffset(0, keyOffset, 0)
  }

  static addValue(
    builder: flatbuffers.Builder,
    valueOffset: flatbuffers.Offset
  ) {
    builder.addFieldOffset(1, valueOffset, 0)
  }

  static addTyp(builder: flatbuffers.Builder, typ: ResultType) {
    builder.addFieldInt8(2, typ, ResultType.Check)
  }

  static endResult(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject()
    return offset
  }
}

export class Metric {
  bb: flatbuffers.ByteBuffer | null = null
  bb_pos = 0
  __init(i: number, bb: flatbuffers.ByteBuffer): Metric {
    this.bb_pos = i
    this.bb = bb
    return this
  }

  static getRootAsMetric(bb: flatbuffers.ByteBuffer, obj?: Metric): Metric {
    return (obj || new Metric()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    )
  }

  static getSizePrefixedRootAsMetric(
    bb: flatbuffers.ByteBuffer,
    obj?: Metric
  ): Metric {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH)
    return (obj || new Metric()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    )
  }

  key(): string | null
  key(optionalEncoding: flatbuffers.Encoding): string | Uint8Array | null
  key(optionalEncoding?: any): string | Uint8Array | null {
    const offset = this.bb!.__offset(this.bb_pos, 4)
    return offset
      ? this.bb!.__string(this.bb_pos + offset, optionalEncoding)
      : null
  }

  value(obj?: TypeWrapper): TypeWrapper | null {
    const offset = this.bb!.__offset(this.bb_pos, 6)
    return offset
      ? (obj || new TypeWrapper()).__init(
          this.bb!.__indirect(this.bb_pos + offset),
          this.bb!
        )
      : null
  }

  static startMetric(builder: flatbuffers.Builder) {
    builder.startObject(2)
  }

  static addKey(builder: flatbuffers.Builder, keyOffset: flatbuffers.Offset) {
    builder.addFieldOffset(0, keyOffset, 0)
  }

  static addValue(
    builder: flatbuffers.Builder,
    valueOffset: flatbuffers.Offset
  ) {
    builder.addFieldOffset(1, valueOffset, 0)
  }

  static endMetric(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject()
    return offset
  }
}

export class Results {
  bb: flatbuffers.ByteBuffer | null = null
  bb_pos = 0
  __init(i: number, bb: flatbuffers.ByteBuffer): Results {
    this.bb_pos = i
    this.bb = bb
    return this
  }

  static getRootAsResults(bb: flatbuffers.ByteBuffer, obj?: Results): Results {
    return (obj || new Results()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    )
  }

  static getSizePrefixedRootAsResults(
    bb: flatbuffers.ByteBuffer,
    obj?: Results
  ): Results {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH)
    return (obj || new Results()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    )
  }

  entries(index: number, obj?: Result): Result | null {
    const offset = this.bb!.__offset(this.bb_pos, 4)
    return offset
      ? (obj || new Result()).__init(
          this.bb!.__indirect(
            this.bb!.__vector(this.bb_pos + offset) + index * 4
          ),
          this.bb!
        )
      : null
  }

  entriesLength(): number {
    const offset = this.bb!.__offset(this.bb_pos, 4)
    return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0
  }

  static startResults(builder: flatbuffers.Builder) {
    builder.startObject(1)
  }

  static addEntries(
    builder: flatbuffers.Builder,
    entriesOffset: flatbuffers.Offset
  ) {
    builder.addFieldOffset(0, entriesOffset, 0)
  }

  static createEntriesVector(
    builder: flatbuffers.Builder,
    data: flatbuffers.Offset[]
  ): flatbuffers.Offset {
    builder.startVector(4, data.length, 4)
    for (let i = data.length - 1; i >= 0; i--) {
      builder.addOffset(data[i]!)
    }
    return builder.endVector()
  }

  static startEntriesVector(builder: flatbuffers.Builder, numElems: number) {
    builder.startVector(4, numElems, 4)
  }

  static endResults(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject()
    return offset
  }

  static createResults(
    builder: flatbuffers.Builder,
    entriesOffset: flatbuffers.Offset
  ): flatbuffers.Offset {
    Results.startResults(builder)
    Results.addEntries(builder, entriesOffset)
    return Results.endResults(builder)
  }
}

export class Metrics {
  bb: flatbuffers.ByteBuffer | null = null
  bb_pos = 0
  __init(i: number, bb: flatbuffers.ByteBuffer): Metrics {
    this.bb_pos = i
    this.bb = bb
    return this
  }

  static getRootAsMetrics(bb: flatbuffers.ByteBuffer, obj?: Metrics): Metrics {
    return (obj || new Metrics()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    )
  }

  static getSizePrefixedRootAsMetrics(
    bb: flatbuffers.ByteBuffer,
    obj?: Metrics
  ): Metrics {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH)
    return (obj || new Metrics()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    )
  }

  entries(index: number, obj?: Metric): Metric | null {
    const offset = this.bb!.__offset(this.bb_pos, 4)
    return offset
      ? (obj || new Metric()).__init(
          this.bb!.__indirect(
            this.bb!.__vector(this.bb_pos + offset) + index * 4
          ),
          this.bb!
        )
      : null
  }

  entriesLength(): number {
    const offset = this.bb!.__offset(this.bb_pos, 4)
    return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0
  }

  static startMetrics(builder: flatbuffers.Builder) {
    builder.startObject(1)
  }

  static addEntries(
    builder: flatbuffers.Builder,
    entriesOffset: flatbuffers.Offset
  ) {
    builder.addFieldOffset(0, entriesOffset, 0)
  }

  static createEntriesVector(
    builder: flatbuffers.Builder,
    data: flatbuffers.Offset[]
  ): flatbuffers.Offset {
    builder.startVector(4, data.length, 4)
    for (let i = data.length - 1; i >= 0; i--) {
      builder.addOffset(data[i]!)
    }
    return builder.endVector()
  }

  static startEntriesVector(builder: flatbuffers.Builder, numElems: number) {
    builder.startVector(4, numElems, 4)
  }

  static endMetrics(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject()
    return offset
  }

  static createMetrics(
    builder: flatbuffers.Builder,
    entriesOffset: flatbuffers.Offset
  ): flatbuffers.Offset {
    Metrics.startMetrics(builder)
    Metrics.addEntries(builder, entriesOffset)
    return Metrics.endMetrics(builder)
  }
}

export class Metadata {
  bb: flatbuffers.ByteBuffer | null = null
  bb_pos = 0
  __init(i: number, bb: flatbuffers.ByteBuffer): Metadata {
    this.bb_pos = i
    this.bb = bb
    return this
  }

  static getRootAsMetadata(
    bb: flatbuffers.ByteBuffer,
    obj?: Metadata
  ): Metadata {
    return (obj || new Metadata()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    )
  }

  static getSizePrefixedRootAsMetadata(
    bb: flatbuffers.ByteBuffer,
    obj?: Metadata
  ): Metadata {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH)
    return (obj || new Metadata()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    )
  }

  testsuite(): string | null
  testsuite(optionalEncoding: flatbuffers.Encoding): string | Uint8Array | null
  testsuite(optionalEncoding?: any): string | Uint8Array | null {
    const offset = this.bb!.__offset(this.bb_pos, 4)
    return offset
      ? this.bb!.__string(this.bb_pos + offset, optionalEncoding)
      : null
  }

  version(): string | null
  version(optionalEncoding: flatbuffers.Encoding): string | Uint8Array | null
  version(optionalEncoding?: any): string | Uint8Array | null {
    const offset = this.bb!.__offset(this.bb_pos, 6)
    return offset
      ? this.bb!.__string(this.bb_pos + offset, optionalEncoding)
      : null
  }

  testcase(): string | null
  testcase(optionalEncoding: flatbuffers.Encoding): string | Uint8Array | null
  testcase(optionalEncoding?: any): string | Uint8Array | null {
    const offset = this.bb!.__offset(this.bb_pos, 10)
    return offset
      ? this.bb!.__string(this.bb_pos + offset, optionalEncoding)
      : null
  }

  builtAt(): string | null
  builtAt(optionalEncoding: flatbuffers.Encoding): string | Uint8Array | null
  builtAt(optionalEncoding?: any): string | Uint8Array | null {
    const offset = this.bb!.__offset(this.bb_pos, 12)
    return offset
      ? this.bb!.__string(this.bb_pos + offset, optionalEncoding)
      : null
  }

  teamslug(): string | null
  teamslug(optionalEncoding: flatbuffers.Encoding): string | Uint8Array | null
  teamslug(optionalEncoding?: any): string | Uint8Array | null {
    const offset = this.bb!.__offset(this.bb_pos, 14)
    return offset
      ? this.bb!.__string(this.bb_pos + offset, optionalEncoding)
      : null
  }

  static startMetadata(builder: flatbuffers.Builder) {
    builder.startObject(6)
  }

  static addTestsuite(
    builder: flatbuffers.Builder,
    testsuiteOffset: flatbuffers.Offset
  ) {
    builder.addFieldOffset(0, testsuiteOffset, 0)
  }

  static addVersion(
    builder: flatbuffers.Builder,
    versionOffset: flatbuffers.Offset
  ) {
    builder.addFieldOffset(1, versionOffset, 0)
  }

  static addTestcase(
    builder: flatbuffers.Builder,
    testcaseOffset: flatbuffers.Offset
  ) {
    builder.addFieldOffset(3, testcaseOffset, 0)
  }

  static addBuiltAt(
    builder: flatbuffers.Builder,
    builtAtOffset: flatbuffers.Offset
  ) {
    builder.addFieldOffset(4, builtAtOffset, 0)
  }

  static addTeamslug(
    builder: flatbuffers.Builder,
    teamslugOffset: flatbuffers.Offset
  ) {
    builder.addFieldOffset(5, teamslugOffset, 0)
  }

  static endMetadata(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject()
    return offset
  }

  static createMetadata(
    builder: flatbuffers.Builder,
    testsuiteOffset: flatbuffers.Offset,
    versionOffset: flatbuffers.Offset,
    testcaseOffset: flatbuffers.Offset,
    builtAtOffset: flatbuffers.Offset,
    teamslugOffset: flatbuffers.Offset
  ): flatbuffers.Offset {
    Metadata.startMetadata(builder)
    Metadata.addTestsuite(builder, testsuiteOffset)
    Metadata.addVersion(builder, versionOffset)
    Metadata.addTestcase(builder, testcaseOffset)
    Metadata.addBuiltAt(builder, builtAtOffset)
    Metadata.addTeamslug(builder, teamslugOffset)
    return Metadata.endMetadata(builder)
  }
}

export class Message {
  bb: flatbuffers.ByteBuffer | null = null
  bb_pos = 0
  __init(i: number, bb: flatbuffers.ByteBuffer): Message {
    this.bb_pos = i
    this.bb = bb
    return this
  }

  static getRootAsMessage(bb: flatbuffers.ByteBuffer, obj?: Message): Message {
    return (obj || new Message()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    )
  }

  static getSizePrefixedRootAsMessage(
    bb: flatbuffers.ByteBuffer,
    obj?: Message
  ): Message {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH)
    return (obj || new Message()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    )
  }

  metadata(obj?: Metadata): Metadata | null {
    const offset = this.bb!.__offset(this.bb_pos, 4)
    return offset
      ? (obj || new Metadata()).__init(
          this.bb!.__indirect(this.bb_pos + offset),
          this.bb!
        )
      : null
  }

  results(obj?: Results): Results | null {
    const offset = this.bb!.__offset(this.bb_pos, 6)
    return offset
      ? (obj || new Results()).__init(
          this.bb!.__indirect(this.bb_pos + offset),
          this.bb!
        )
      : null
  }

  metrics(obj?: Metrics): Metrics | null {
    const offset = this.bb!.__offset(this.bb_pos, 10)
    return offset
      ? (obj || new Metrics()).__init(
          this.bb!.__indirect(this.bb_pos + offset),
          this.bb!
        )
      : null
  }

  static startMessage(builder: flatbuffers.Builder) {
    builder.startObject(4)
  }

  static addMetadata(
    builder: flatbuffers.Builder,
    metadataOffset: flatbuffers.Offset
  ) {
    builder.addFieldOffset(0, metadataOffset, 0)
  }

  static addResults(
    builder: flatbuffers.Builder,
    resultsOffset: flatbuffers.Offset
  ) {
    builder.addFieldOffset(1, resultsOffset, 0)
  }

  static addMetrics(
    builder: flatbuffers.Builder,
    metricsOffset: flatbuffers.Offset
  ) {
    builder.addFieldOffset(3, metricsOffset, 0)
  }

  static endMessage(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject()
    return offset
  }
}

export class MessageBuffer {
  bb: flatbuffers.ByteBuffer | null = null
  bb_pos = 0
  __init(i: number, bb: flatbuffers.ByteBuffer): MessageBuffer {
    this.bb_pos = i
    this.bb = bb
    return this
  }

  static getRootAsMessageBuffer(
    bb: flatbuffers.ByteBuffer,
    obj?: MessageBuffer
  ): MessageBuffer {
    return (obj || new MessageBuffer()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    )
  }

  static getSizePrefixedRootAsMessageBuffer(
    bb: flatbuffers.ByteBuffer,
    obj?: MessageBuffer
  ): MessageBuffer {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH)
    return (obj || new MessageBuffer()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    )
  }

  buf(index: number): number | null {
    const offset = this.bb!.__offset(this.bb_pos, 4)
    return offset
      ? this.bb!.readUint8(this.bb!.__vector(this.bb_pos + offset) + index)
      : 0
  }

  bufLength(): number {
    const offset = this.bb!.__offset(this.bb_pos, 4)
    return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0
  }

  bufArray(): Uint8Array | null {
    const offset = this.bb!.__offset(this.bb_pos, 4)
    return offset
      ? new Uint8Array(
          this.bb!.bytes().buffer,
          this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset),
          this.bb!.__vector_len(this.bb_pos + offset)
        )
      : null
  }

  static startMessageBuffer(builder: flatbuffers.Builder) {
    builder.startObject(1)
  }

  static addBuf(builder: flatbuffers.Builder, bufOffset: flatbuffers.Offset) {
    builder.addFieldOffset(0, bufOffset, 0)
  }

  static createBufVector(
    builder: flatbuffers.Builder,
    data: number[] | Uint8Array
  ): flatbuffers.Offset {
    builder.startVector(1, data.length, 1)
    for (let i = data.length - 1; i >= 0; i--) {
      builder.addInt8(data[i]!)
    }
    return builder.endVector()
  }

  static startBufVector(builder: flatbuffers.Builder, numElems: number) {
    builder.startVector(1, numElems, 1)
  }

  static endMessageBuffer(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject()
    return offset
  }

  static createMessageBuffer(
    builder: flatbuffers.Builder,
    bufOffset: flatbuffers.Offset
  ): flatbuffers.Offset {
    MessageBuffer.startMessageBuffer(builder)
    MessageBuffer.addBuf(builder, bufOffset)
    return MessageBuffer.endMessageBuffer(builder)
  }
}

export class Messages {
  bb: flatbuffers.ByteBuffer | null = null
  bb_pos = 0
  __init(i: number, bb: flatbuffers.ByteBuffer): Messages {
    this.bb_pos = i
    this.bb = bb
    return this
  }

  static getRootAsMessages(
    bb: flatbuffers.ByteBuffer,
    obj?: Messages
  ): Messages {
    return (obj || new Messages()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    )
  }

  static getSizePrefixedRootAsMessages(
    bb: flatbuffers.ByteBuffer,
    obj?: Messages
  ): Messages {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH)
    return (obj || new Messages()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    )
  }

  messages(index: number, obj?: MessageBuffer): MessageBuffer | null {
    const offset = this.bb!.__offset(this.bb_pos, 4)
    return offset
      ? (obj || new MessageBuffer()).__init(
          this.bb!.__indirect(
            this.bb!.__vector(this.bb_pos + offset) + index * 4
          ),
          this.bb!
        )
      : null
  }

  messagesLength(): number {
    const offset = this.bb!.__offset(this.bb_pos, 4)
    return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0
  }

  static startMessages(builder: flatbuffers.Builder) {
    builder.startObject(1)
  }

  static addMessages(
    builder: flatbuffers.Builder,
    messagesOffset: flatbuffers.Offset
  ) {
    builder.addFieldOffset(0, messagesOffset, 0)
  }

  static createMessagesVector(
    builder: flatbuffers.Builder,
    data: flatbuffers.Offset[]
  ): flatbuffers.Offset {
    builder.startVector(4, data.length, 4)
    for (let i = data.length - 1; i >= 0; i--) {
      builder.addOffset(data[i]!)
    }
    return builder.endVector()
  }

  static startMessagesVector(builder: flatbuffers.Builder, numElems: number) {
    builder.startVector(4, numElems, 4)
  }

  static endMessages(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject()
    return offset
  }

  static finishMessagesBuffer(
    builder: flatbuffers.Builder,
    offset: flatbuffers.Offset
  ) {
    builder.finish(offset)
  }

  static finishSizePrefixedMessagesBuffer(
    builder: flatbuffers.Builder,
    offset: flatbuffers.Offset
  ) {
    builder.finish(offset, undefined, true)
  }

  static createMessages(
    builder: flatbuffers.Builder,
    messagesOffset: flatbuffers.Offset
  ): flatbuffers.Offset {
    Messages.startMessages(builder)
    Messages.addMessages(builder, messagesOffset)
    return Messages.endMessages(builder)
  }
}

export function unionToType(
  type: Type,
  accessor: (
    obj: T_Array | Bool | Double | Float | Int | T_Object | T_String | UInt
  ) => T_Array | Bool | Double | Float | Int | T_Object | T_String | UInt | null
): T_Array | Bool | Double | Float | Int | T_Object | T_String | UInt | null {
  switch (Type[type]) {
    case 'NONE':
      return null
    case 'Bool':
      return accessor(new Bool())! as Bool
    case 'Int':
      return accessor(new Int())! as Int
    case 'UInt':
      return accessor(new UInt())! as UInt
    case 'Float':
      return accessor(new Float())! as Float
    case 'Double':
      return accessor(new Double())! as Double
    case 'String':
      return accessor(new T_String())! as T_String
    case 'Object':
      return accessor(new T_Object())! as T_Object
    case 'Array':
      return accessor(new T_Array())! as T_Array
    default:
      return null
  }
}

export function unionListToType(
  type: Type,
  accessor: (
    index: number,
    obj: T_Array | Bool | Double | Float | Int | T_Object | T_String | UInt
  ) =>
    | T_Array
    | Bool
    | Double
    | Float
    | Int
    | T_Object
    | T_String
    | UInt
    | null,
  index: number
): T_Array | Bool | Double | Float | Int | T_Object | T_String | UInt | null {
  switch (Type[type]) {
    case 'NONE':
      return null
    case 'Bool':
      return accessor(index, new Bool())! as Bool
    case 'Int':
      return accessor(index, new Int())! as Int
    case 'UInt':
      return accessor(index, new UInt())! as UInt
    case 'Float':
      return accessor(index, new Float())! as Float
    case 'Double':
      return accessor(index, new Double())! as Double
    case 'String':
      return accessor(index, new T_String())! as T_String
    case 'Object':
      return accessor(index, new T_Object())! as T_Object
    case 'Array':
      return accessor(index, new T_Array())! as T_Array
    default:
      return null
  }
}

export class Assertion {
  bb: flatbuffers.ByteBuffer | null = null
  bb_pos = 0
  __init(i: number, bb: flatbuffers.ByteBuffer): Assertion {
    this.bb_pos = i
    this.bb = bb
    return this
  }

  static getRootAsAssertion(
    bb: flatbuffers.ByteBuffer,
    obj?: Assertion
  ): Assertion {
    return (obj || new Assertion()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    )
  }

  static getSizePrefixedRootAsAssertion(
    bb: flatbuffers.ByteBuffer,
    obj?: Assertion
  ): Assertion {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH)
    return (obj || new Assertion()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    )
  }

  static startAssertion(builder: flatbuffers.Builder) {
    builder.startObject(2)
  }

  static endAssertion(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject()
    return offset
  }
}

export class Assertions {
  bb: flatbuffers.ByteBuffer | null = null
  bb_pos = 0
  __init(i: number, bb: flatbuffers.ByteBuffer): Assertions {
    this.bb_pos = i
    this.bb = bb
    return this
  }

  static getRootAsAssertions(
    bb: flatbuffers.ByteBuffer,
    obj?: Assertions
  ): Assertions {
    return (obj || new Assertions()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    )
  }

  static getSizePrefixedRootAsAssertions(
    bb: flatbuffers.ByteBuffer,
    obj?: Assertions
  ): Assertions {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH)
    return (obj || new Assertions()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    )
  }

  static startAssertions(builder: flatbuffers.Builder) {
    builder.startObject(1)
  }

  static endAssertions(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject()
    return offset
  }

  static createAssertions(builder: flatbuffers.Builder): flatbuffers.Offset {
    Assertions.startAssertions(builder)
    return Assertions.endAssertions(builder)
  }
}
