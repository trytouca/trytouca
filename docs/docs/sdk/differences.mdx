import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";
import { HiCheckCircle } from "react-icons/hi";

# Feature Matrix

export class Check extends React.Component {
  render() {
    return <HiCheckCircle color="green" size="1.25rem" />;
  }
}

This section lists notable differences between SDKs in different languages.

| Syntax                                              | Python    | JavaScript | C++       | Java      |
| --------------------------------------------------- | --------- | ---------- | --------- | --------- |
| [Custom comparison rules](#custom-comparison-rules) | <Check /> | <Check />  |           | <Check /> |
| [Configuration profiles](#configuration-profiles)   | <Check /> | <Check />  | <Check /> | <Check /> |
| [Version auto-increment](#version-auto-increment)   | <Check /> | <Check />  | <Check /> | <Check /> |
| [Results Store](#results-store)                     | <Check /> | <Check />  | <Check /> | <Check /> |
| [Multiple workflows](#multiple-workflows)           | <Check /> | <Check />  | <Check /> | <Check /> |
| Capturing binary blobs                              | <Check /> | <Check />  |           |           |
| Capturing external files                            | <Check /> | <Check />  |           |           |
| Run tests via the CLI                               | <Check /> |            |           |           |
| Stream redirection                                  |           |            | <Check /> |           |
| External logging                                    |           |            | <Check /> |           |

## Custom comparison rules

<Tabs
  groupId="sdks"
  defaultValue="python"
  values={[
    { label: "Python", value: "python" },
    { label: "JavaScript", value: "js" },
    { label: "Java", value: "java" }
  ]}
>
<TabItem value="python">

```py
touca.check("gpa", student.gpa, rule=touca.decimal_rule.absolute(min=3))
```

</TabItem>
<TabItem value="js">

```ts
touca.check("gpa", student.gpa, {
  rule: { type: "number", mode: "absolute", min: 3 }
});
```

</TabItem>
<TabItem value="java">

```java
Touca.check("gpa", student.gpa, DecimalRule.absolute(x -> {
  x.setMin(3);
}));
```

With the Java SDK, you need to explicitly import the comparison rule that you
are using.

```java
import io.touca.rules.DecimalRule;
```

</TabItem>
</Tabs>

## Configuration profiles

When running Touca tests, you typically need to pass certain options such as
your API Key. Using command-line arguments to pass this information may not be
very convenient. Since the values of these options rarely change, it's easier to
set them in a configuration profile to be looked up and applied automatically as
you run your tests.

You can use the Touca CLI sub-commands to manage configuration profiles (via
[`touca profile`](../cli#configuration-profiles)) and set and remove options
from the active configuration profile (via
[`touca config`](../cli#configuration-options)).

All Touca SDKs support automatically loading configuration options from the
active configuration profile.

## Version auto-increment

You can set most test configuration parameters in a configuration profile
because they rarely change from one version to another, except the version
itself. In CI pipelines, it may make sense to set the version as an environment
variable that corresponds to your build version. But if you are running tests
locally, passing the version as a command-line argument and incrementing it
every time may be inconvenient. To fix this, when you do not specify the
version, the SDKs query Touca server for the latest submitted version and
automatically increment it by minor version.

This feature is supported by all SDKs.

## Results store

By default, any local file generated during the test run such as test reuslt
files (in binary or json format) will be written in a `.touca/results` directory
that is placed in the `$HOME` directory unless environment variable
`TOUCA_HOME_DIR` is specified or that a `.touca` directory already exists in the
current working directory.

You can conveniently browse and manage binary archives of the results store
using the Touca CLI via the `touca results` command.

## Multiple workflows

You can define any number of test workflows and run one or all of them as part
of the same test. The test runner will execute the code under test with the test
cases for each workflow and submits the test results to the corresponding suite.
You can use command line option `--filter` to limit the test run to any given
workflow.

<Tabs
  groupId="sdks"
  defaultValue="python"
  values={[
    { label: "Python", value: "python" },
    { label: "JavaScript", value: "js" },
    { label: "C++", value: "cpp" },
    { label: "Java", value: "java"}
  ]}
>
<TabItem value="python">

In Python, each function in any module (in the current working directory or the
specified test directory) that is decorated with `@touca.workflow` will be
considered a separate workflow.

```py
@touca.workflow(testcases=["alice", "bob", "charlie"])
def students_test(username: str):
    student = code_under_test.find_student(username)
    touca.check("gpa", student.gpa)

@touca.workflow(testcases=["banana", "orange"])
def fruits_test(name: str):
    fruit = code_under_test.find_color(name)
    touca.check("color", fruite.color)
```

</TabItem>
<TabItem value="js">

In TypeScript, every callback function given to `touca.workflow` is considered a
separate workflow.

```ts
touca.workflow(
  "students_test",
  async (username: string) => {
    const student = await find_student(username);
    touca.check("gpa", student.gpa);
  },
  { testcases: ["alice", "bob", "charlie"] }
);

touca.workflow(
  "fruits_test",
  (name: string) => {
    const fruit = find_fruit(name);
    touca.check("color", fruit.color);
  },
  { testcases: ["banana", "orange"] }
);
```

</TabItem>
<TabItem value="cpp">

In C++, every lambda function given to `touca::workflow` is considered a
separate workflow.

```cpp
touca::workflow(
    "students_test",
    [](const std::string& username) {
      const auto& student = find_student(username);
      touca::check("gpa", student.gpa);
    },
    [](touca::WorkflowOptions& w) {
      w.testcases = {"alice", "bob", "charlie"};
    });

touca::workflow(
    "fruits_test",
    [](const std::string& name) {
      const auto& fruit = find_fruit(name);
      touca::check("color", fruit.color);
    },
    [](touca::WorkflowOptions& w) {
      w.testcases = {"banana", "orange"};
    });
```

</TabItem>
<TabItem value="java">

In Java, each function in any class (in the same package as the class given to
the `Touca.run` function) that is decorated with `@Touca.Workflow` is considered
a separate workflow.

```java
public final class ToucaTests {

  @Touca.Workflow
  public void findStudent(final String username) {
    Student student = Students.findStudent(username);
    Touca.check("gpa", student.gpa);
  }

  @Touca.Workflow
  public void findFruit(final String name) {
    Fruit fruit = Fruits.findFruit(name);
    Touca.check("color", fruit.color);
  }

  public static void main(String[] args) {
    Touca.setWorkflowOptions("findStudent", x -> {
      x.testcases = new String[] { "alice", "bob", "charlie" };
    });
    Touca.setWorkflowOptions("findFruit", x -> {
      x.testcases = new String[] { "banana", "orange" };
    });
    Touca.run(ToucaTests.class, args);
  }
}
```

</TabItem>
</Tabs>
