# C++ Test Framework

Previously, we learned how to build a Regression Test Tool for a trivial Code Under Test using the Touca Client Library for C++. The Library is designed to be low-level and extensible enough to allow us to extend that pattern to test any Workflow of arbitrary complexity. But as we build more Test Tools, we learn that our Test Tools share many similarities in structure and common features.

To reduce possible code duplications and enable code reuse, Touca provides a separate Test Framework for C++ with a modular and extensible design. By implementing common features, the Test Framework can unify the behavior and the code structure of our Test Tools to make developing and maintaining them less consuming.

In this section, we demonstrate some of the capabilities of this Test Framework by building a new Regression Test Tool for the same trivial Code Under Test that we used in the "[C++ Client Library](cpp-library.md)" document.

## Common Features

Touca Test Framework is designed to help engineers focus on implementing the test execution workflow of a given Test Case by abstracting away the common features of Regression Test Tools. Some of these common features are listed below.

* Parsing Command Line Arguments

  The Framework already supports many useful command-line options out of the box and makes it easy to add and parse extra workflow-specific options.

* Parsing Configuration Files

  The Framework already supports extracting configuration parameters from a separate configuration file.

* Initializing Workflow-Specific Resources

  Engineers can easily define and configure any resources related to the Code Under Test, such as Log Files, helper classes etc.

* Extraction of Log Events

  Engineers can extract the log events generated by the Framework and redirect them to their own logger.

* Managing List of Test Cases

  The Framework allows engineers to create reusable Test Suites with custom logic for extracting the list of Test Cases. It also offers several plug-and-play Test Suites that can obtain the list of Test Cases from the Touca Platform or by parsing a given file.

* Capturing Output of Code Under Test

  The Framework redirects any content written to standard output or standard error when executing the Code Under Test to separate files for easier inspection and post-processing.

* Managing Data Storage on Filesystem

  The Framework can create and maintain a directory hierarchy in which Result files, log files, and other Workflow-specific files can be stored based on the names of the Workflow, Revision, and Test Case that are executed.

* Skipping Already Executed Test Cases

  The Framework allows engineers to specify the conditions in which a given Test Case should be skipped for a particular Revision of the Code Under Test.

* Reporting Execution Progress

  For each executed Test Case, the Framework reports the name of the Test Case, its execution runtime, and any error that it may have produced.

* Handling Errors and Exceptions

  The Framework catches and reports any returned error or thrown exception of the Code Under Test to help ensure the failure of a given Test Case does not disrupt the overall test process.

* Integrating with the Touca Client Library

  The Framework automatically calls the lower-level Touca Client functions following all the recommended best practices. It configures the Touca Client, declares Test Cases, submits test Results, etc. It allows engineers to disable any interaction with the Touca Platform if they so choose.

## The Main Function

Touca Test Framework has an entry-point `touca::framework::main` that is meant to be called from the main function of our Test Tool using the following pattern.

```cpp
int main(int argc, char* argv[])
{
    MyWorkflow workflow;
    return touca::framework::main(argc, argv, workflow);
}
```

This function takes over running our application for any given Workflow. In the example above, MyWorkflow is a class derived from the abstract class `touca::framework::Workflow`.

## The Workflow Class

The Workflow Class helps us describe our Test Workflow. It encapsulates any logic that distinguishes our Test Tool from other Regression Test Tools. This class is given to the `main` function of the Test Framework that calls its different member functions in a specific order. Most member functions have a trivial default implementation that gives the engineers the option to override them and provide their own custom code.

See our Reference API documentation for a complete list of the member functions of the Workflow class and the order in which they are called.

There are two member function that _must_ be implemented:

* `Workflow::execute` is meant to describe how a particular Test Case should be executed. This is the function that we override to pass our Test Cases to the Code Under Test.

  In the `is_prime` example that we reviewed in the `Getting Started` document, the following code snippet may serve as a possible implementation of this function.

  ```cpp
  touca::framework::Errors execute(
    const touca::framework::Testcase& testcase) const override
  {
      const auto input_number = std::stoul(testcase);
      touca::add_assertion("input_number", input_number);
      touca::start_timer("overall runtime");
      touca::add_result("is_prime", is_prime(input_number));
      touca::stop_timer("overall runtime");
      return {};
  }
  ```

* `Workflow::suite` is meant to describe how a list of our Test Cases should be obtained when we run the Test Tool. Since many test tools may use the same approach to obtain this list, we describe this logic in a separate instance of the `Suite` class.

## The Suite Class

Touca Test Framework allows us to formulate how the list of our Test Cases should be obtained by deriving from class `touca::framework::Suite`.

In our `is_prime` example, we used a list of eight numbers as our set of inputs to the Code Under Test. The following code snippet shows one way to represent this list by deriving from the Suite class:

```cpp
class MySuite final : public touca::framework::Suite
{
public:
    MySuite() : Suite()
    {
        for (const auto number: { 1, 2, 3, 4, 7, 673, 7453, 14747 })
        {
            push(std::to_string(number));
        }
    }
};
```

Then we can use this class to implement `Workflow::suite`:

```cpp
std::shared_ptr<touca::framework::Suite> suite() const override
{
    return std::make_shared<MySuite>();
}
```

But as we mentioned in the "Getting Started" document, it is helpful to ensure that the list of Test Cases can be modified without the need to rebuild our Test Tool. One way to do so is to list our Test Case in an external file to be read and parsed at runtime.

Touca provides a few prepared implementations of the `Suite` class. One of these available implementations is the `FileSuite` that can help achieve our goal:

```cpp
std::shared_ptr<touca::framework::Suite> suite() const override
{
    return std::make_shared<touca::framework::FileSuite>("suite.txt");
}
```

## The Final Test Tool

Putting things together, the code snippet below shows a basic implementation for our Regression Test Tool using Touca Test Framework for C++.

{% code title="regression\_test.hpp" %}
```cpp
#include "code_under_test.hpp"
#include "touca/touca.hpp"
#include "touca/framework.hpp"
#include "touca/framework/suites.hpp"

namespace wf = touca::framework;

class MyWorkflow : public wf::Workflow
{
public:
    std::shared_ptr<wf::Suite> suite() const override
    {
        return std::make_shared<wf::FileSuite>("suite.txt");
    }

    wf::Errors execute(const wf::Testcase& testcase) const override
    {
        const auto input_number = std::stoul(testcase);
        touca::add_assertion("input_number", input_number);
        touca::start_timer("overall runtime");
        touca::add_result("is_prime", is_prime(input_number));
        touca::stop_timer("overall runtime");
        return {};
    }
};

int main(int argc, char* argv[])
{
    MyWorkflow workflow;
    return wf::main(argc, argv, workflow);
}
```
{% endcode %}

We can test any Revision of the Code Under Test by passing command-line options `--revision` and `--config-file` as shown below:

```bash
$ ./regression_test -c ./config.json -r 1.0
```

Where `config.json` may have the following content:

{% code title="config.json" %}
```javascript
{
  "framework": {
    "output-dir": "./output",
    "save-as-binary": "true",
    "save-as-json": "false"
  },
  "touca": {
    "api-key": "0eb962f2-84cd-4a01-9721-c339dc335972",
    "api-url": "https://api.touca.io/@/myteam/is_prime"
  }
}
```
{% endcode %}

And `suite.txt` simply lists our Test Cases:

{% code title="suite.txt" %}
```text
1
2
3
4
7
673
7453
14747
```
{% endcode %}

We can expect the test to produce an output similar to what is shown below:

```text
Touca Regression Test Framework
Suite: is_prime
Revision: 1.0

 (  1 of 8  ) 1                                (pass, 0 ms)
 (  2 of 8  ) 2                                (pass, 0 ms)
 (  3 of 8  ) 3                                (pass, 0 ms)
 (  4 of 8  ) 4                                (pass, 0 ms)
 (  5 of 8  ) 7                                (pass, 0 ms)
 (  6 of 8  ) 673                              (pass, 0 ms)
 (  7 of 8  ) 745                              (pass, 0 ms)
 (  8 of 8  ) 14747                            (pass, 0 ms)

processed 8 of 8 testcases
test completed in 0 ms
```

## Customizing

Touca Test Framework allows us to provide a custom implementation for the member functions of the Workflow class. The set of supported configuration options are also customizable. In this section, we briefly demonstrate how these features can be used.

The example provided in the previous section extracts the list of Test Cases from a text file with a fixed filename `suite.txt`. Let us try to make this filename configurable.

One way to make this file configurable is to add it to the list of configuration parameters specified in our application configuration file.

{% code title="config.json" %}
```javascript
{
  "framework": {
    "output-dir": "./output",
    "save-as-binary": "true",
    "save-as-json": "false"
  },
  "touca": {
    "api-key": "0eb962f2-84cd-4a01-9721-c339dc335972",
    "api-url": "https://api.touca.io/@/myteam/is_prime"
  },
  "workflow": {
    "suite-file": "./suite.txt"
  }
}
```
{% endcode %}

Doing so makes this configuration parameter available in any member function of the `Workflow` class through the `_options` member variable. This allows us to change the implementation of member function `suite()` to the following:

```cpp
std::shared_ptr<wf::Suite> suite() const override
{
    return std::make_shared<wf::FileSuite>(_options.at("suite-file"));
}
```

This change makes `suite-file` a required configuration option. We can make ensure that this option is always provided by implementing the member function `Workflow::validate_options`.

```cpp
bool validate_options() const override
{
    return _options.count("suite-file");
}
```

If we decide to declare this parameter as a command-line option, it suffices that we implement the member function `Workflow::parse_options` and append the value parsed from the command line arguments to the member variable `_options` by calling `Workflow::add_option`. If we do so, it also makes sense to implement `Workflow::describe_options` to provide a simple string that is shown to the user if they run the Test Tool with the option `--help`.

